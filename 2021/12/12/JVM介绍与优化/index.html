<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.svg">
  <link rel="mask-icon" href="/images/icon.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/pink/pace-theme-material.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"he-zhifei.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.11.0/config.min.js"></script>

    <meta name="description" content="包括字节码、类的加载、运行时数据区、对象内存布局、执行引擎、垃圾回收、性能监控、性能优化。">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM介绍与优化">
<meta property="og:url" content="https://he-zhifei.github.io/2021/12/12/JVM%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="Zhifei&#39;s Blog">
<meta property="og:description" content="包括字节码、类的加载、运行时数据区、对象内存布局、执行引擎、垃圾回收、性能监控、性能优化。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://he-zhifei.github.io/img/default_heap_size.png">
<meta property="og:image" content="https://he-zhifei.github.io/img/object_structure.png">
<meta property="og:image" content="https://he-zhifei.github.io/img/gc_relation.png">
<meta property="og:image" content="https://he-zhifei.github.io/img/G1_heap.png">
<meta property="og:image" content="https://he-zhifei.github.io/img/Snipaste_2024-09-22_12-45-25.png">
<meta property="og:image" content="https://he-zhifei.github.io/img/Snipaste_2024-10-05_17-25-59.png">
<meta property="og:image" content="https://he-zhifei.github.io/img/Snipaste_2024-10-05_18-46-03.png">
<meta property="og:image" content="https://he-zhifei.github.io/img/Snipaste_2024-10-06_17-34-39.png">
<meta property="article:published_time" content="2021-12-12T03:24:11.000Z">
<meta property="article:modified_time" content="2024-10-06T22:19:53.465Z">
<meta property="article:author" content="he-zhifei">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://he-zhifei.github.io/img/default_heap_size.png">


<link rel="canonical" href="https://he-zhifei.github.io/2021/12/12/JVM%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BC%98%E5%8C%96/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://he-zhifei.github.io/2021/12/12/JVM%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BC%98%E5%8C%96/","path":"2021/12/12/JVM介绍与优化/","title":"JVM介绍与优化"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JVM介绍与优化 | Zhifei's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>

  <script type="text/javascript" src="/js/my_js/click_love.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <!-- 粘贴到这里 -->
  <!--
  <a target="_blank" rel="noopener" href="https://github.com/he-zhifei" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  -->

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Zhifei's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>文章</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-text">1. 字节码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-text">1.1 前端编译器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-text">1.2 Class文件结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8"><span class="nav-text">1.3 符号引用和直接引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="nav-text">1.4 字节码指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E6%A1%88%E4%BE%8B%E4%B8%80"><span class="nav-text">1）案例一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E6%A1%88%E4%BE%8B%E4%BA%8C"><span class="nav-text">2）案例二</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-text">2. 类的加载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-text">2.1 加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-%E5%8A%A0%E8%BD%BD-Loading"><span class="nav-text">2.1.1 加载(Loading)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-%E9%93%BE%E6%8E%A5-Linking"><span class="nav-text">2.1.2 链接(Linking)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E9%AA%8C%E8%AF%81-Verification"><span class="nav-text">1）验证(Verification)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E5%87%86%E5%A4%87-Preparation"><span class="nav-text">2）准备(Preparation)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%BC%89%E8%A7%A3%E6%9E%90-Resolution"><span class="nav-text">3）解析(Resolution)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-%E5%88%9D%E5%A7%8B%E5%8C%96-Initialization"><span class="nav-text">2.1.3 初始化(Initialization)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4-%E4%BD%BF%E7%94%A8-Using"><span class="nav-text">2.1.4 使用(Using)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-5-%E5%8D%B8%E8%BD%BD-Unloading"><span class="nav-text">2.1.5 卸载(Unloading)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">2.2 类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E5%88%86%E7%B1%BB"><span class="nav-text">2.2.1 分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-%E7%89%B9%E5%BE%81"><span class="nav-text">2.2.2 特征</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-text">3. 运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-text">3.1 程序计数器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E7%89%B9%E7%82%B9"><span class="nav-text">3.1.1 特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-text">3.2 虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E6%A0%88%E5%B8%A7"><span class="nav-text">3.2.1 栈帧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%EF%BC%88Local-Variables%EF%BC%89"><span class="nav-text">1）局部变量表（Local Variables）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%EF%BC%88Operand-Stack%EF%BC%89"><span class="nav-text">2）操作数栈（Operand Stack）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%BC%89%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88Dynamic-Linking%EF%BC%89"><span class="nav-text">3）动态链接（Dynamic Linking）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%EF%BC%89%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%EF%BC%88Return-Address%EF%BC%89"><span class="nav-text">4）方法返回地址（Return Address）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%EF%BC%89%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="nav-text">5）附加信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E7%9B%B8%E5%85%B3JVM%E5%8F%82%E6%95%B0"><span class="nav-text">3.2.2 相关JVM参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-%E7%89%B9%E7%82%B9"><span class="nav-text">3.2.3 特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-text">3.3 本地方法栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E7%89%B9%E7%82%B9"><span class="nav-text">3.3.1 特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E5%A0%86"><span class="nav-text">3.4 堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E5%88%86%E4%BB%A3"><span class="nav-text">3.4.1 分代</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E6%96%B0%E7%94%9F%E4%BB%A3"><span class="nav-text">1）新生代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-text">2）老年代</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E7%9B%B8%E5%85%B3JVM%E5%8F%82%E6%95%B0"><span class="nav-text">3.4.2 相关JVM参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-%E7%89%B9%E7%82%B9"><span class="nav-text">3.4.3 特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-text">3.5 方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E7%9B%B8%E5%85%B3JVM%E5%8F%82%E6%95%B0"><span class="nav-text">3.5.1 相关JVM参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-%E7%89%B9%E7%82%B9"><span class="nav-text">3.5.2 特点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-text">4. 对象内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text">4.1 对象的实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">1）对象创建的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-text">2）对象创建的步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-text">4.2 对象的内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-text">4.3 对象的访问定位</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="nav-text">5. 执行引擎</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">6. 垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E5%9E%83%E5%9C%BE%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95"><span class="nav-text">6.1 垃圾判定算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-text">6.1.1 引用计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="nav-text">6.1.2 可达性分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-text">6.2 垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%88Mark-Sweep%EF%BC%89"><span class="nav-text">6.2.1 标记-清除算法（Mark-Sweep）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%88Copying%EF%BC%89"><span class="nav-text">6.2.2 复制算法（Copying）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%EF%BC%88Mark-Compact%EF%BC%89"><span class="nav-text">6.2.3 标记-整理算法（Mark-Compact）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-4-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-text">6.2.4 分代收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-5-%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-text">6.2.5 增量收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-6-%E5%88%86%E5%8C%BA%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-text">6.2.6 分区收集算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-gc-%E4%B8%8Efinalize"><span class="nav-text">6.3 gc()与finalize()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-text">6.4 内存溢出与内存泄漏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-1-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-text">6.4.1 内存溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-2-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-text">6.4.2 内存泄漏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E9%9D%99%E6%80%81%E9%9B%86%E5%90%88%E7%B1%BB"><span class="nav-text">1）静态集合类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-text">2）单例模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%BC%89%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E6%8C%81%E6%9C%89%E5%A4%96%E9%83%A8%E7%B1%BB"><span class="nav-text">3）非静态内部类持有外部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%EF%BC%89%E5%90%84%E7%A7%8D%E8%B5%84%E6%BA%90%E8%BF%9E%E6%8E%A5"><span class="nav-text">4）各种资源连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%EF%BC%89%E5%8F%98%E9%87%8F%E4%B8%8D%E5%90%88%E7%90%86%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">5）变量不合理的作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%EF%BC%89%E6%94%B9%E5%8F%98%E5%93%88%E5%B8%8C%E5%80%BC"><span class="nav-text">6）改变哈希值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%EF%BC%89%E7%BC%93%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-text">7）缓存泄漏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%EF%BC%89%E7%9B%91%E5%90%AC%E5%99%A8%E5%92%8C%E5%9B%9E%E8%B0%83"><span class="nav-text">8）监听器和回调</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-%E5%BC%95%E7%94%A8%E5%88%86%E7%B1%BB"><span class="nav-text">6.5 引用分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-STW%EF%BC%88Stop-The-World%EF%BC%89"><span class="nav-text">6.6 STW（Stop-The-World）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1-%E5%AE%89%E5%85%A8%E7%82%B9%EF%BC%88Safepoint%EF%BC%89"><span class="nav-text">6.6.1 安全点（Safepoint）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2-%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%EF%BC%88Safe-Region%EF%BC%89"><span class="nav-text">6.6.2 安全区域（Safe Region）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7-%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-text">6.7 并行与并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-8-%E4%B8%83%E4%B8%AA%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">6.8 七个经典垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-1-Serial%E3%80%81Serial-Old"><span class="nav-text">6.8.1 Serial、Serial Old</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-2-ParNew"><span class="nav-text">6.8.2 ParNew</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-3-Parallel-Scavenge%E3%80%81Parallel-Old"><span class="nav-text">6.8.3 Parallel Scavenge、Parallel Old</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-4-CMS"><span class="nav-text">6.8.4 CMS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-5-G1"><span class="nav-text">6.8.5 G1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-9-GC%E6%97%A5%E5%BF%97%E5%8F%82%E6%95%B0"><span class="nav-text">6.9 GC日志参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7"><span class="nav-text">7. 性能监控</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-OOM%E5%88%86%E6%9E%90"><span class="nav-text">7.1 OOM分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%A0%86%E6%BA%A2%E5%87%BA"><span class="nav-text">1）堆溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89GC-overhead-limit-exceeded"><span class="nav-text">2）GC overhead limit exceeded</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E6%96%B9%E6%B3%95%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="nav-text">3）方法区溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="nav-text">4）栈溢出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="nav-text">7.2 命令行工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89jps"><span class="nav-text">1）jps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89jstat"><span class="nav-text">2）jstat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89jinfo"><span class="nav-text">3）jinfo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89jmap"><span class="nav-text">4）jmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%89jhat"><span class="nav-text">5）jhat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%EF%BC%89jstack"><span class="nav-text">6）jstack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%EF%BC%89jcmd"><span class="nav-text">7）jcmd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%EF%BC%89jstatd"><span class="nav-text">8）jstatd</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-GUI%E5%B7%A5%E5%85%B7"><span class="nav-text">7.3 GUI工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B"><span class="nav-text">8. 优化案例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-%E8%B0%83%E6%95%B4%E5%A0%86%E5%A4%A7%E5%B0%8F%E6%8F%90%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-text">8.1 调整堆大小提高吞吐量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-JVM%E4%BC%98%E5%8C%96%E4%B9%8BJTI%E4%BC%98%E5%8C%96"><span class="nav-text">8.2 JVM优化之JTI优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1-%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="nav-text">8.2.1 标量替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-2-%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D"><span class="nav-text">8.2.2 栈上分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-3-%E9%94%81%EF%BC%88%E5%90%8C%E6%AD%A5%EF%BC%89%E6%B6%88%E9%99%A4%E5%90%8E"><span class="nav-text">8.2.3 锁（同步）消除后</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-%E5%90%88%E7%90%86%E9%85%8D%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98"><span class="nav-text">8.3 合理配置堆内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-CPU%E9%AB%98%E5%8D%A0%E7%94%A8%E7%9A%84%E6%8E%92%E6%9F%A5"><span class="nav-text">8.4 CPU高占用的排查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-G1%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-text">8.5 G1并发线程数对性能的影响</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-%E8%B0%83%E6%95%B4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%8F%90%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-text">8.6 调整垃圾收集器提高吞吐量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-7-%E6%97%A5%E5%9D%87%E7%99%BE%E4%B8%87%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9FJVM%E5%8F%82%E6%95%B0%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-text">8.7 日均百万订单系统JVM参数的设置</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E9%A1%B5"><span class="nav-text">附页</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="he-zhifei"
      src="/images/profile-pic.svg">
  <p class="site-author-name" itemprop="name">he-zhifei</p>
  <div class="site-description" itemprop="description">keep it up.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/he-zhifei" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;he-zhifei" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:he-zhifei@foxmail.com" title="E-Mail → mailto:he-zhifei@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://example.com/" title="https:&#x2F;&#x2F;example.com" rel="noopener" target="_blank">友情链接</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

  <a href="https://github.com/he-zhifei" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://he-zhifei.github.io/2021/12/12/JVM%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile-pic.svg">
      <meta itemprop="name" content="he-zhifei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhifei's Blog">
      <meta itemprop="description" content="keep it up.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JVM介绍与优化 | Zhifei's Blog">
      <meta itemprop="description" content="包括字节码、类的加载、运行时数据区、对象内存布局、执行引擎、垃圾回收、性能监控、性能优化。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM介绍与优化
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-12 11:24:11" itemprop="dateCreated datePublished" datetime="2021-12-12T11:24:11+08:00">2021-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-07 06:19:53" itemprop="dateModified" datetime="2024-10-07T06:19:53+08:00">2024-10-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>32k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:55</span>
    </span>
</div>

            <div class="post-description">包括字节码、类的加载、运行时数据区、对象内存布局、执行引擎、垃圾回收、性能监控、性能优化。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="1-字节码"><a href="#1-字节码" class="headerlink" title="1. 字节码"></a>1. 字节码</h1><p>关于JDK的命名：在官方正式文档中，开发版本号在JDK 10及之后取消1.x的命名方式，公开版本号在JDK 5及之后取消了这种命名方式，即：JDK 1.0 ~ JDK 1.4、JDK 5 ~ JDK X。</p>
<p>有Class对象的类型：类、接口、数组、枚举、注解、基本数据类型、void。</p>
<p>JVM中的数据类型：8种基本数据类型、对象引用（reference类型）和returnAddress类型。</p>
<p>为什么不把基本数据类型放入堆中：堆空间大，但运算速度慢；复杂数据类型在创建时无法确定其大小，为了不影响栈的效率，放入堆中；基本数据类型比较稳定，并且占用空间小，放入运算速度快的栈中，能提高效率。</p>
<p>Java没有指针，参数传递是值传递。</p>
<h2 id="1-1-前端编译器"><a href="#1-1-前端编译器" class="headerlink" title="1.1 前端编译器"></a>1.1 前端编译器</h2><p>负责把java文件编译成class文件，不涉及编译优化的问题，优化细节交给JIT负责。比如：</p>
<ul>
<li>javac（全量编译，与之相反的工具javap），编译步骤：词法解析、语法解析、语义解析、生成字节码。</li>
<li>ECJ(Eclipse Complier for Java，增量编译)</li>
<li>AJC(IDEA的AspectJ编译器，IDEA默认使用javac)。</li>
</ul>
<h2 id="1-2-Class文件结构"><a href="#1-2-Class文件结构" class="headerlink" title="1.2 Class文件结构"></a>1.2 Class文件结构</h2><p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。</p>
<p>1）Class文件结构的数据类型：</p>
<ul>
<li>无符号数：属于基本的数据类型，包含1、2、4、8个字节的无符号数，用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li>
<li>表：由多个无符号数或其它表作为数据项构成的复合数据类型，它的命名习惯地以“_info”结尾。用来描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表。</li>
</ul>
<p>2）Class文件结构：</p>
<ul>
<li><p>魔数（Magic Number）：前4个字节（固定为0xCAFEBABE），决定Class文件是否能被虚拟机接受。</p>
</li>
<li><p>Class文件的版本：魔数之后的4个字节，第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。</p>
</li>
<li><p>常量池：Class文件版本之后为常量池入口，常量池中常量的数量是不固定的，是占用Class文件空间最大的数据项目。前2个子节表示常量池容量计数值（constant_pool_count），它是某些指向常量池数据的索引值。常量池的容量计数是从1开始的（0表示不引用任何一个常量池项目），其它集合类型的容量计数一般从0开始。常量池主要存放两大类常量：</p>
<ul>
<li>字面量（Literal）：文本字符串、被声明为final的常量值等。</li>
<li>符号引用（Symbolic References），主要包括：<ul>
<li>被模块导出或者开放的包（Package）</li>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul>
</li>
</ul>
<p>作用：存放编译时期生成的字面量和符号引用，经过类加载的解析之后，这部分内容进入运行时常量池。</p>
<p>虚拟机在加载Class文件时才进行动态连接。也就是说，在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话，无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机进行类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>
</li>
<li><p>访问标志：常量池之后的2个子节为访问标志（access_flags），用来识别类或接口的访问信息，包括：是类还是接口；是否是public类型；是否是abstract类型；如果是类，是否被声明为final；等等。</p>
</li>
<li><p>类索引、父类索引与接口索引集合：</p>
<ul>
<li>类索引（this_class）：2个子节，用来确定这个类的全限定名</li>
<li>父类索引（super_class）：2个子节，用来确定这个类的父类的全限定名。除了java.lang.Object之外，所有Java类的父类索引都不为0。</li>
<li>接口索引集合 （interfaces）是一组2个子节数据的集合。用来描述这个类实现的所有接口，被实现的接口按implements关键字（如果Class文件表示的是接口，则是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</li>
</ul>
<p>作用：这三项数据用来确定类型的继承关系。</p>
</li>
<li><p>字段表集合：字段表（field_info）用来描述接口或类声明的变量（类变量、实例变量）。包括的修饰符有：</p>
<ul>
<li><p>字段的作用域（public、private、protected修饰符）</p>
</li>
<li><p>是实例变量还是类变量（static修饰符）</p>
</li>
<li><p>可变性（final）</p>
</li>
<li><p>并发可见性（volatile修饰符，是否强制从主内存读写）</p>
</li>
<li><p>可否被序列化（transient修饰符）</p>
</li>
<li><p>字段数据类型（基本类型、对象、数组）</p>
</li>
<li><p>字段名称。</p>
</li>
</ul>
<p>各个修饰符都是布尔值，要么有某个修饰符，要么没有，使用标志位来表示。而字段的名字、字段的数据类型，长度无法固定，引用常量池的常量来描述。</p>
</li>
<li><p>方法表集合：对方法的描述与对字段的描述基本相同，方法表的结构与字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）。这些数据项目的含义也与字段表中的类似，仅在访问标志和属性表集合的可选项中有所区别。</p>
<ul>
<li>访问标志的区别：因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，synchronized、native、strictfp和abstract关键字可以修饰方法，方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、 ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。</li>
</ul>
</li>
<li><p>属性表集合：Class文件、字段表、方法表都可以携带自己的属性表（attribute_info）集合，以描述某些场景专有的信息。</p>
</li>
</ul>
<h2 id="1-3-符号引用和直接引用"><a href="#1-3-符号引用和直接引用" class="headerlink" title="1.3 符号引用和直接引用"></a>1.3 符号引用和直接引用</h2><ul>
<li><p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</p>
</li>
<li><p>直接引用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p>
</li>
</ul>
<h2 id="1-4-字节码指令"><a href="#1-4-字节码指令" class="headerlink" title="1.4 字节码指令"></a>1.4 字节码指令</h2><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode） 以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。其中，大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。</p>
<p>指令大致分为九类：加载和存储指令、运算指令、类型转换指令、对象创建与访问指令、操作数栈管理指令、控制转移指令、方法调用和返回指令、异常处理指令、同步指令。如下是与方法调用相关的指令：</p>
<ul>
<li>invokevirtual：调用实例方法</li>
<li>invokeinterface：调用接口方法</li>
<li>invokespecial：调用需要特殊处理的实例方法，包括构造器、私有方法和父类方法。这些方法都是静态类型绑定的，不会在调用时进行动态派发。</li>
<li>invokestatic：调用类中的类方法（静态方法），这是静态绑定的。</li>
<li>invokedynamic：调用动态绑定的方法，JDK 7后加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面4条调用指令的分派逻辑都固化在java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
<p>IDEA中查看字节码指令插件：jclasslib bytecode viewer（先build&#x3D;&gt; recompile，然后view &#x3D;&gt; show bytecode）。</p>
<h3 id="1）案例一"><a href="#1）案例一" class="headerlink" title="1）案例一"></a>1）案例一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节码：</span></span><br><span class="line"><span class="comment">     *  0 bipush 10     操作数栈顶插入10</span></span><br><span class="line"><span class="comment">     *  2 istore_1      拿出操作数栈顶元素，插入局部变量表下标为1的位置</span></span><br><span class="line"><span class="comment">     *  3 iinc 1 by 1   局部变量表下标1的位置自增1</span></span><br><span class="line"><span class="comment">     *  6 getstatic #2 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span></span><br><span class="line"><span class="comment">     *  9 iload_1       把局部变量表下标1的位置元素插入到操作数栈顶部</span></span><br><span class="line"><span class="comment">     * 10 invokevirtual #3 &lt;java/io/PrintStream.println : (I)V&gt;</span></span><br><span class="line"><span class="comment">     * 13 return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//        i++;</span></span><br><span class="line">        ++i;    <span class="comment">// 这里的两者字节码完全相同</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        i = i++;</span><br><span class="line">        System.out.println(i);  <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        i *= i++;</span><br><span class="line">        System.out.println(i);  <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        k = k + (k++) + (++k);</span><br><span class="line">        System.out.println(k);  <span class="comment">// 32</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前两行字节码：</span></span><br><span class="line"><span class="comment">     *  0 bipush 10     操作数栈顶插入10</span></span><br><span class="line"><span class="comment">     *  2 invokestatic #4 &lt;java/lang/Integer.valueOf : (I)Ljava/lang/Integer;&gt;  调用Integer.valueOf创建对象</span></span><br><span class="line"><span class="comment">     *  5 astore_1      把对象引用插入到局部变量表下标1位置</span></span><br><span class="line"><span class="comment">     *  6 bipush 10</span></span><br><span class="line"><span class="comment">     *  8 invokestatic #4 &lt;java/lang/Integer.valueOf : (I)Ljava/lang/Integer;&gt;</span></span><br><span class="line"><span class="comment">     * 11 astore_2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 结合java.lang.Integer#valueOf(int)在-128~127范围内使用缓存中的对象，因此i1 == i2为true，i3 == i4为false；</span></span><br><span class="line"><span class="comment">     * 同理java.lang.Boolean#valueOf(boolean)内部有两个常量，因此b1 == b2为true；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 包装类对象的缓存：</span></span><br><span class="line"><span class="comment">     * Byte/Short/Integer/Long      -128~127</span></span><br><span class="line"><span class="comment">     * Float/Double                 没有缓存</span></span><br><span class="line"><span class="comment">     * Character                    0-127</span></span><br><span class="line"><span class="comment">     * Boolean                      true、false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(i1 == i2);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        System.out.println(i3 == i4);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        System.out.println(b1 == b2);   <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过字面量的方式创建的String对象都放在字符串常量池中；</span></span><br><span class="line"><span class="comment">     * JDK 6字符串常量池放在方法区（永久代）；</span></span><br><span class="line"><span class="comment">     * JDK 7及之后字符串常量池放在堆空间；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串常量池中若存在此字符串，返回该对象；不存在则添加到池中，并返回该对象。</span></span><br><span class="line"><span class="comment">//        str1.intern();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;aaabbb&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不调用intern时-false。调用intern时，java6及之前-false；之后-true。</span></span><br><span class="line">        System.out.println(str1 == str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  0 sipush 128    操作数栈顶插入128</span></span><br><span class="line"><span class="comment">     *  3 invokestatic #4 &lt;java/lang/Integer.valueOf : (I)Ljava/lang/Integer;&gt;</span></span><br><span class="line"><span class="comment">     *  6 astore_1      对象引用插入局部变量表下标1的位置</span></span><br><span class="line"><span class="comment">     *  7 sipush 128    操作数栈顶插入128</span></span><br><span class="line"><span class="comment">     * 10 istore_2      拿出操作数栈顶元素，插入局部变量表下标2位置</span></span><br><span class="line"><span class="comment">     * 11 getstatic #2 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span></span><br><span class="line"><span class="comment">     * 14 aload_1       操作数栈顶插入局部变量表下标1位置保存的引用</span></span><br><span class="line"><span class="comment">     * 15 invokevirtual #16 &lt;java/lang/Integer.intValue : ()I&gt;  操作数栈顶元素调用Integer.intValue（拆箱）</span></span><br><span class="line"><span class="comment">     * 18 iload_2</span></span><br><span class="line"><span class="comment">     * 19 if_icmpne 26 (+7)     比较</span></span><br><span class="line"><span class="comment">     * 22 iconst_1</span></span><br><span class="line"><span class="comment">     * 23 goto 27 (+4)</span></span><br><span class="line"><span class="comment">     * 26 iconst_0</span></span><br><span class="line"><span class="comment">     * 27 invokevirtual #5 &lt;java/io/PrintStream.println : (Z)V&gt;</span></span><br><span class="line"><span class="comment">     * 30 return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        System.out.println(i1 == i2);   <span class="comment">// true，根据字节码显示：拆箱再比较</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）案例二"><a href="#2）案例二" class="headerlink" title="2）案例二"></a>2）案例二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.print();</span><br><span class="line">        n = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A.n = &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.print();</span><br><span class="line">        n = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B.n = &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * B.n = 0</span></span><br><span class="line"><span class="comment"> * B.n = 10</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    System.out.println(a.n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-类的加载"><a href="#2-类的加载" class="headerlink" title="2. 类的加载"></a>2. 类的加载</h1><h2 id="2-1-加载过程"><a href="#2-1-加载过程" class="headerlink" title="2.1 加载过程"></a>2.1 加载过程</h2><h3 id="2-1-1-加载-Loading"><a href="#2-1-1-加载-Loading" class="headerlink" title="2.1.1 加载(Loading)"></a>2.1.1 加载(Loading)</h3><p>加载的对象：基本数据类型由虚拟机预先定义，引用数据类型需要进行类加载。</p>
<p>加载完成3件事：</p>
<ol>
<li>通过类的全名来获取类的二进制数据流。</li>
<li>解析类的二进制数据流为方法区的运行时数据结构。</li>
<li>在内存中生成代表这个类的java.lang.Class对象（类模板对象），作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>目的：简单来说，就是加载类的字节码到方法区（JDK 8之前永久代，JDK 8及之后元空间），并在堆中生成代表这个类的Class对象。存储在方法区的数据为类的元数据（instanceKlass对象），包括类型信息、方法信息、字段信息等；存储在堆中的是类的Class对象，作为访问类的元数据的入口。</p>
<p>类模板对象获取方式：类.class、类实例.getClass()、Class.forName(“类的全名”)。</p>
<p>数组类的加载有所不同，数组类本身不通过类加载器创建，它是由JVM直接在内存中动态构造出来的，但数组元素类型仍然需要类加载器进行加载，遵循如下规则：</p>
<ol>
<li>若数组的组件类型（去掉一个维度的类型）为引用类型，则递归采用类加载过程进行加载。数组类将被标识在加载该组件类型的类加载器的类名称空间上。</li>
<li>若数组的组件类型不是引用类型，JVM会将数组类与引导类加载器关联。</li>
<li>数组类的可访问性与它的组件类型的可访问性一致，若组件类型不是引用类型，数组类的可访问性为public。</li>
</ol>
<p>同一个类，只会被同一个类加载器加载一次，但可以通过不同类加载器进行多次加载。</p>
<h3 id="2-1-2-链接-Linking"><a href="#2-1-2-链接-Linking" class="headerlink" title="2.1.2 链接(Linking)"></a>2.1.2 链接(Linking)</h3><h4 id="1）验证-Verification"><a href="#1）验证-Verification" class="headerlink" title="1）验证(Verification)"></a>1）验证(Verification)</h4><p>验证阶段大致上会完成下面四个阶段的检验动作：</p>
<ol>
<li>文件格式验证：魔数、版本等。</li>
<li>元数据验证：是否有父类、是否继承了final类等。</li>
<li>字节码验证：保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作、保证任何跳转指令都不会跳转到方法体以外的字节码指令上等。</li>
<li>符号引用验证：验证符号引用指向的类、方法、字段等资源是否存在。</li>
</ol>
<p>目的：保证字节码是合法、合理并符合规范的。</p>
<h4 id="2）准备-Preparation"><a href="#2）准备-Preparation" class="headerlink" title="2）准备(Preparation)"></a>2）准备(Preparation)</h4><p>目的：为类的静态变量分配内存，并初始化为默认值。</p>
<p>注意：静态变量指的是static、非final修饰的变量（也即类变量），值为字面量的静态常量（static final）在准备阶段分配内存并赋值；这个阶段不会有代码执行，真正的赋值操作在初始化阶段，通过<code>&lt;clinit&gt;()</code>方法执行。JVM各类型默认初始值如下表：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>boolean</td>
<td>false（Java内部通过int实现，默认值为0，因此默认false）</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<h4 id="3）解析-Resolution"><a href="#3）解析-Resolution" class="headerlink" title="3）解析(Resolution)"></a>3）解析(Resolution)</h4><p>目的：将类、接口、字段、方法的符号引用转为直接引用。</p>
<p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后再开始， 这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。</p>
<h3 id="2-1-3-初始化-Initialization"><a href="#2-1-3-初始化-Initialization" class="headerlink" title="2.1.3 初始化(Initialization)"></a>2.1.3 初始化(Initialization)</h3><p>目的：通过执行类构造器<code>&lt;clinit&gt;()</code>方法，对静态变量进行赋值。</p>
<p><code>&lt;clinit&gt;()</code>方法：编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生。如果没有类变量或静态代码块赋值，则不会产生该方法。执行子类的<code>&lt;clinit&gt;()</code>之前，会先执行父类的<code>&lt;clinit&gt;()</code>，因此父类静态代码块先于子类静态代码块执行。</p>
<p><code>&lt;init&gt;()</code>方法：一定会出现在Class的method表中。</p>
<p>不会产生<code>&lt;clinit&gt;()</code>方法的情况：</p>
<ol>
<li>类中没有静态变量，也没有静态代码块；</li>
<li>类中有静态变量，但无显式赋值；</li>
<li>类中只有静态常量，且其值为字面量；若其值为方法的执行结果，则会产生<code>&lt;clinit&gt;()</code>方法。</li>
</ol>
<p><code>&lt;clinit&gt;()</code>方法加锁，线程安全，演示类加载死锁的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(<span class="string">&quot;com.zhifei.A&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(<span class="string">&quot;com.zhifei.B&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.zhifei.B&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;A.static initializer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.zhifei.A&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;B.static initializer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会进行类的初始化的情况（主动使用，有<code>&lt;clinit&gt;()</code>方法的调用）：</p>
<ol>
<li>通过new创建对象。（new）</li>
<li>使用静态变量（值为字面量的常量除外）。（getstatic、putstatic）</li>
<li>调用静态方法。（invokestatic）</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<p>不会进行类的初始化的情况（被动使用，没有<code>&lt;clinit&gt;()</code>方法的调用）：</p>
<ol>
<li>子类引用父类的静态字段，不会导致子类初始化。</li>
<li>通过数组定义来引用类，不会触发此类的初始化。</li>
<li>引用常量不会触发该类或接口的初始化。其在链接的准备阶段已经完成赋值。</li>
<li>通过ClassLoader的loadClass()加载类，不会触发类的初始化。</li>
</ol>
<p>测试题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tst</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Tst</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tst</span>(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Tst</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tst</span>(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> print(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;non-static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> print(<span class="string">&quot;j&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        print(<span class="string">&quot;static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tst</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println((k++) + <span class="string">&quot; - &quot;</span> + str + <span class="string">&quot; i=&quot;</span> + (++i) + <span class="string">&quot; n=&quot;</span> + (n++));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println((k++) + <span class="string">&quot; - &quot;</span> + str + <span class="string">&quot; i=&quot;</span> + (++i) + <span class="string">&quot; n=&quot;</span> + (n++));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 11 - non-static i=1 n=0</span></span><br><span class="line"><span class="comment">     * 12 - j i=2 n=1</span></span><br><span class="line"><span class="comment">     * 13 - t1 i=3 n=2</span></span><br><span class="line"><span class="comment">     * 14 - non-static i=4 n=3</span></span><br><span class="line"><span class="comment">     * 15 - j i=5 n=4</span></span><br><span class="line"><span class="comment">     * 16 - t2 i=6 n=5</span></span><br><span class="line"><span class="comment">     * 17 - i i=7 n=6</span></span><br><span class="line"><span class="comment">     * 18 - static i=8 n=20</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-使用-Using"><a href="#2-1-4-使用-Using" class="headerlink" title="2.1.4 使用(Using)"></a>2.1.4 使用(Using)</h3><h3 id="2-1-5-卸载-Unloading"><a href="#2-1-5-卸载-Unloading" class="headerlink" title="2.1.5 卸载(Unloading)"></a>2.1.5 卸载(Unloading)</h3><p>前言：每个类加载器持有其加载所有类的集合，同理，Class对象持有加载该类的类加载器，类加载器与Class对象是双向关联的关系。任一个对象持有其Class对象的引用（class属性）。</p>
<p>因此，要想卸载类：</p>
<ol>
<li>类加载器置为null。（不只有一个类被该加载器加载的情况，不建议置为null，只适合自定义的单一类被该类加载器加载的情况。）</li>
<li>所有实例置为null。</li>
<li>引用其class的变量置为null。</li>
</ol>
<p>故，已经加载的类被卸载的几率极低，开发过程中，也不应该去卸载。</p>
<h2 id="2-2-类加载器"><a href="#2-2-类加载器" class="headerlink" title="2.2 类加载器"></a>2.2 类加载器</h2><h3 id="2-2-1-分类"><a href="#2-2-1-分类" class="headerlink" title="2.2.1 分类"></a>2.2.1 分类</h3><ol>
<li><p>启动类加载器（引导类加载器，BootStrap）</p>
<p>1）使用C&#x2F;C++语言实现，嵌套在JVM内部。</p>
<p>2）不继承java.lang.ClassLoader，没有父类加载器。</p>
<p>3）加载Java的核心库（jre&#x2F;lib&#x2F;rt.jar、sun.boot.class.path下类库）。</p>
<p>4）出于安全考虑，只加载包名以java、javax、sun等开头的类。</p>
<p>5）加载扩展类加载器和应用程序类加载器，并指定为它们的父类加载器。</p>
</li>
<li><p>扩展类加载器（ExtClassLoader）</p>
<p>1）Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</p>
<p>2）继承java.lang.ClassLoader，父类加载器为启动类加载器。</p>
<p>3）加载jre&#x2F;lib&#x2F;ext目录下的类库或系统变量java.ext.dirs指定目录下的类库。</p>
</li>
<li><p>应用程序类加载器（系统类加载器，AppClassLoader）</p>
<p>1）Java语言编写，由sun.misc.Launcher$AppClassLoader实现。</p>
<p>2）继承java.lang.ClassLoader，父类加载器为扩展类加载器。</p>
<p>3）加载用户类路径classpath所有的类库或系统变量java.class.path指定目录下的类库。</p>
<p>4）它是应用程序中默认的类加载器，也是自定义类加载器的默认父类加载器。</p>
<p>5）可通过ClassLoader的getSystemClassLoader()获取。</p>
</li>
<li><p>自定义加载器（继承ClassLoader），可实现：隔离加载类（同一个tomcat不同应用的程序）、修改类加载方式、扩展加载源（数据库、网络）、防止源码泄露（还原加密的字节码）。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定类的类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> A.class.getClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前线程上下文的类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">ccl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取系统类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">scl</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br></pre></td></tr></table></figure>

<p>自定义类加载器源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhifei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuzClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CuzClassLoader</span><span class="params">(String rootPath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rootPath = rootPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) &#123;</span><br><span class="line">        <span class="comment">// 转换为文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> classNameToFilePath(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取字节码的二进制流</span></span><br><span class="line">        <span class="type">byte</span>[] data = loadFromFilePath(filePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用defineClass()，其下调用了preDefineClass()，对java.开头的类库进行了保护，即不能通过自定义的类加载器进行加载。</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadFromFilePath(String filePath) &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">                <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">classNameToFilePath</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rootPath + <span class="string">&quot;/&quot;</span> + name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CuzClassLoader</span> <span class="variable">ccl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CuzClassLoader</span>(<span class="string">&quot;D:\\codes\\juc-jvm-demo\\src\\main\\java&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; clz1 = ccl1.findClass(<span class="string">&quot;com.zhifei.CuzClassLoaderByte&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">CuzClassLoader</span> <span class="variable">ccl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CuzClassLoader</span>(<span class="string">&quot;D:\\codes\\juc-jvm-demo\\src\\main\\java&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; clz2 = ccl2.findClass(<span class="string">&quot;com.zhifei.CuzClassLoaderByte&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;clz1 == clz2 ? &quot;</span> + (clz1 == clz2));</span><br><span class="line">        clz1.newInstance();</span><br><span class="line">        clz2.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-特征"><a href="#2-2-2-特征" class="headerlink" title="2.2.2 特征"></a>2.2.2 特征</h3><ol>
<li>双亲委派机制：一个类的加载会先委派给父类加载器加载，父类加载器也是如此，所以先由Bootstrap加载，如果无法加载，再由ExtClassLoader加载，如果再加载不了，则由AppClassLoader加载。优点：避免类重复加载；保护核心类库。缺点：顶层的类加载器不能访问底层的类加载器。</li>
<li>可见性：子类加载器可以访问父类加载器加载的类型，反过来不允许。</li>
<li>单一性：父类加载器加载后，子类加载器不会重复加载。但类加载器”邻居“间，同一类型可以被加载多次，其相互间不可见。</li>
</ol>
<hr>
<p>破坏双亲委派机制：</p>
<p>第一次破坏：由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。</p>
<p>第二次破坏：顶层的类加载器不能访问底层的类加载器。线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p>第三次破坏：用户对程序动态性的追求而导致的，这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等。</p>
<p>另外，Tomcat的自定义类加载器破坏了双亲委派机制，其解决了：</p>
<ol>
<li>同一个Web容器，多个应用程序类库独立，相互隔离。</li>
<li>同一个Web容器，多个应用程序间相同版本的类库共享。</li>
<li>Web容器自身类库与应用程序类库相互隔离。</li>
<li>支持jsp热部署。</li>
</ol>
<hr>
<p>沙箱机制就是将Java代码限定只能在虚JVM虚拟机中特定的运行范围，并且严格限制代码对本地系统资源访问，通过这样的方式来保证对Java代码的有效隔离，防止对本地操作系统造成破坏。主要限制系统资源（CPU、内存、文件系统、网络）的访问。</p>
<ul>
<li>JDK 1.0安全模型本地代码可以访问系统资源，远程代码无法访问系统资源，比如用户希望远程代码访问本地系统的文件时候，就无法实现。</li>
<li>JDK 1.1安全模型版本中，针对安全机制做了改进，增加了受信任安全策略，允许用户指定代码对本地资源的访问权限。</li>
<li>JDK 1.2安全模型改进了安全机制，增加了代码签名。不论本地代码或是远程代码，统一按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，从而来实现差异化的代码执行权限控制。</li>
<li>目前最新的安全模型引入了域(Domain)的概念。JVM虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源系统进行交互，而每个应用域部分则通过系统域的部分代理来对各种需要的资源进行精细划分然后可以进行访问。JVM虚拟机中不同的受保护域(Protected Domain)对应不一样的权限(Permission)。存在于不同域中的类文件就拥有了它所包含应用域所有可访问资源之和。</li>
</ul>
<h1 id="3-运行时数据区"><a href="#3-运行时数据区" class="headerlink" title="3. 运行时数据区"></a>3. 运行时数据区</h1><h2 id="3-1-程序计数器"><a href="#3-1-程序计数器" class="headerlink" title="3.1 程序计数器"></a>3.1 程序计数器</h2><p>​		程序计数器是当前线程所执行的字节码的行号指示器（存储当前线程所执行的字节码指令地址），字节码解释器通过改变计数器的值来选取下一条要执行的字节码指令。它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>​		若线程正在执行的是Java方法，计数器记录的是正在执行的虚拟机字节码指令地址；若正在执行的是本地（Native）方法，计数器的值为空（Undefined），本地方法大多通过C实现，未编译成字节码指令，所以计数器为空。</p>
<p>线程私有的原因：Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，为了保证线程切换后能恢复到正确的执行位置。</p>
<h3 id="3-1-1-特点"><a href="#3-1-1-特点" class="headerlink" title="3.1.1 特点"></a>3.1.1 特点</h3><ol>
<li>线程私有，生命周期与线程的一致。</li>
<li>不存在GC，不存在OOM。</li>
<li>内存小，运行速度在运行时数据区中最快。</li>
</ol>
<h2 id="3-2-虚拟机栈"><a href="#3-2-虚拟机栈" class="headerlink" title="3.2 虚拟机栈"></a>3.2 虚拟机栈</h2><p>​		每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。栈顶元素对应正在执行的方法，方法正常退出或异常退出，栈顶元素都被移除。</p>
<h3 id="3-2-1-栈帧"><a href="#3-2-1-栈帧" class="headerlink" title="3.2.1 栈帧"></a>3.2.1 栈帧</h3><h4 id="1）局部变量表（Local-Variables）"><a href="#1）局部变量表（Local-Variables）" class="headerlink" title="1）局部变量表（Local Variables）"></a>1）局部变量表（Local Variables）</h4><p>​		主要用来存放方法的参数和定义在方法内的局部变量，数据类型包括：8种基本数据类型、对象引用（reference类型）和returnAddress类型。这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，long和double类型数据占用两个变量槽，其余的数据类型只占用一个，下标为0的变量槽存放this（如果是实例方法）。局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小（保存在方法的Code属性的maximum local variables数据项中），这里说的”大小“是指变量槽的数量。局部变量表中的变量只在当前方法调用中有效，当方法调用结束后，局部变量表随着栈帧销毁。</p>
<p>测试局部变量表最大槽数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhifei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LVTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LVTest</span>().test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.info = <span class="string">&quot;test1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">10L</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3，局部变量b创建后又马上销毁，c存放在销毁前b的槽中。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test3</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">            b = a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2，但只有下标为0的槽存放了this，a没有被存放，因为a没有初始化，不能使用。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态变量与局部变量区别：静态变量会进行2次初始化（类加载的准备阶段和初始化阶段）；局部变量在使用前必须手动初始化。</p>
<p>1）局部变量压栈指令：</p>
<ul>
<li>xload_n   x表示数据类型，可选：i、l、f、d、a（引用类型）；n表示局部变量表的下标，可选：0、1、2、3。表示把局部变量表下标为n、类型为x的数据放入操作数栈的顶部。</li>
<li>xload n    x同上，n &gt; 3。</li>
</ul>
<p>2）常数入栈指令（const系列、push系列、ldc系列）：</p>
<p>​	const系列：</p>
<ul>
<li>iconst_m1	将-1压入操作数栈。</li>
<li>iconst_x		将x（0到5）压入操作数栈。</li>
<li>lconst_x		将长整型x（0到1）压入操作数栈。</li>
<li>fconst_x		将浮点数x（0、1、2）压入操作数栈。</li>
<li>dconst_x		将双精度浮点数x（0、1）压入操作数栈。</li>
<li>aconst_null		将null压入操作数栈。</li>
</ul>
<p>​	push系列：</p>
<ul>
<li>bipush		8位整数入栈</li>
<li>sipush		16位整数入栈</li>
</ul>
<p>​	ldc系列：</p>
<ul>
<li>ldc_w		接收两个8位参数，支持索引范围大于ldc</li>
</ul>
<p>3）出栈存入局部变量表：</p>
<ul>
<li>xstore_n	x表示数据类型，可选：i、l、f、d、a（引用类型）；n表示局部变量表的下标，可选：0、1、2、3。表示移除操作数栈顶元素，并存储到局部变量表下标为n的位置。</li>
<li>xstore n    x同上，n &gt; 3。</li>
</ul>
<h4 id="2）操作数栈（Operand-Stack）"><a href="#2）操作数栈（Operand-Stack）" class="headerlink" title="2）操作数栈（Operand Stack）"></a>2）操作数栈（Operand Stack）</h4><p>​		每一个操作数栈（后进先出）都会拥有一个明确的栈深度用于存储数值，其最大深度在编译期就定义好了，保存在方法的Code属性中的max_stack值。long、float占用2个栈深度，其余占用1个栈深度。如果被调用的方法带有返回值，其返回值将会被压入当前栈帧的操作数栈中，并更新程序计数器中下一条需要执行的字节码指令。</p>
<p>测试操作数栈最大深度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhifei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OSTest</span> &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4，return语句中的加法运算，会先把i转为long（指令i2l），因此深度2+2=4</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">10L</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> i + l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>栈顶缓存（Tos，Top-of-Stack Cashing）技术：将栈顶元素全部缓存在物理CPU的寄存器中，来降低对内存的读写次数，提升执行引擎的执行效率。</p>
<h4 id="3）动态链接（Dynamic-Linking）"><a href="#3）动态链接（Dynamic-Linking）" class="headerlink" title="3）动态链接（Dynamic Linking）"></a>3）动态链接（Dynamic Linking）</h4><p>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，使得当前方法的代码支持动态链接。</p>
<p>作用：符号引用转为调用方法的直接引用。</p>
<p>常量池作用：提供符号和常量，便于指令识别。</p>
<p>符号引用转为调用方法的直接引用与方法的绑定机制相关：</p>
<ul>
<li>静态链接：当一个字节码文件被加载进JVM内部时，如果被调用的目标方法在编译期可知，且运行时保持不变。这种情况下将调用方法的符号引用转换为直接引用的过程为静态链接。</li>
<li>动态链接：如果被调用的方法在编译器无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称为动态链接。</li>
</ul>
<p>对应的方法绑定机制（绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。）：</p>
<ul>
<li>早期绑定：被调用的目标方法如果在编译器期可知，且运行期保持不变，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li>
<li>晚期绑定：如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称为晚期绑定。</li>
</ul>
<h4 id="4）方法返回地址（Return-Address）"><a href="#4）方法返回地址（Return-Address）" class="headerlink" title="4）方法返回地址（Return Address）"></a>4）方法返回地址（Return Address）</h4><p>​		存放调用该方法的程序计数器的值，无论方法正常退出或异常退出，都会返回到该方法被调用的位置。正常退出时，调用者的程序计数器的值作为返回地址，即调用该方法的指令下一条指令地址；异常退出时，返回地址要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
<p>退出指令：ireturn（返回值是boolean、byte、char、short、int类型）、lreturn、freturn、dreturn、areturn、return（void方法、实例初始化方法、类和接口初始化方法）。异常退出不会给它的上层调用者产生任何的返回值。</p>
<h4 id="5）附加信息"><a href="#5）附加信息" class="headerlink" title="5）附加信息"></a>5）附加信息</h4><p>《Java虚拟机规范》允许虚拟机的实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现。一般会把动态链接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。</p>
<h3 id="3-2-2-相关JVM参数"><a href="#3-2-2-相关JVM参数" class="headerlink" title="3.2.2 相关JVM参数"></a>3.2.2 相关JVM参数</h3><p><em>size</em>可选的单位：不写单位（子节）、k、K、m、M、g、G。</p>
<ul>
<li>-Xss<em>size</em>（或 -XX:ThreadStackSize&#x3D;<em>size</em>）设置线程的栈内存，32位Linux默认320k，64位Linux默认1024k，Windows下默认值依据虚拟内存。若设置栈空间过大，会导致可创建的线程数减少，通常一个进程有3000-5000个线程。</li>
</ul>
<h3 id="3-2-3-特点"><a href="#3-2-3-特点" class="headerlink" title="3.2.3 特点"></a>3.2.3 特点</h3><ol>
<li>线程私有，生命周期与线程的一致。</li>
<li>不存在GC，存在SOF和OOM。</li>
</ol>
<p>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。（方法无限递归调用；局部变量表过长，导致栈帧过大，没存几个就溢出。）</p>
<p>OutOfMemoryError：如果虚拟机栈容量可以动态扩展，且扩展时无法申请到足够的内存；或者创建新线程时没有足够的内存去创建对应的虚拟机栈。（HotSpot虚拟机的栈容量是不可以动态扩展的，所以HotSpot的虚拟机栈不会出现第一种情况，只可能是创建的线程过多而导致栈的OOM。）</p>
<p>方法中定义的局部变量是否线程安全：如果局部变量在内部产生并在内部消亡，那就是线程安全的。</p>
<h2 id="3-3-本地方法栈"><a href="#3-3-本地方法栈" class="headerlink" title="3.3 本地方法栈"></a>3.3 本地方法栈</h2><p>​		虚拟机栈用来管理Java方法的调用，而本地方法栈用来管理本地方法的调用。当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界，与虚拟机拥有同样的权限。与虚拟机栈类似，也是允许被实现成固定或者可动态扩展的内存大小。</p>
<h3 id="3-3-1-特点"><a href="#3-3-1-特点" class="headerlink" title="3.3.1 特点"></a>3.3.1 特点</h3><ol>
<li>线程私有，生命周期与线程的一致。</li>
<li>不存在GC，存在SOF和OOM（溢出情况与虚拟机栈的类似）。</li>
</ol>
<h2 id="3-4-堆"><a href="#3-4-堆" class="headerlink" title="3.4 堆"></a>3.4 堆</h2><p>​		堆在JVM启动时被创建，空间大小也确定了，是运行时数据区中最大的区域，也是GC的重点区域。一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。在方法结束后，堆中的对象不会立马被移除，仅仅在垃圾收集时才会被移除。几乎所有对象都分配在堆上，除了使用“栈上分配”去特殊处理。</p>
<p>​		所有的线程都共享堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer, TLAB）。</p>
<p>存储在JVM的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期短，对象的创建和消亡都非常迅速。</li>
<li>另一类是生命周期非常长，某些极端情况下与JVM生命周期保持一致。</li>
</ul>
<h3 id="3-4-1-分代"><a href="#3-4-1-分代" class="headerlink" title="3.4.1 分代"></a>3.4.1 分代</h3><p>目的：根据对象不同的生命周期和大小，划分到不同内存区域，按照各自的特性采取不同垃圾收集算法，提高GC效率。对象整体流转过程：①②③④</p>
<h4 id="1）新生代"><a href="#1）新生代" class="headerlink" title="1）新生代"></a>1）新生代</h4><p>新生代（Young &#x2F; New generation，新生区，简写：Young &#x2F; New，YoungGen）：</p>
<ul>
<li>伊甸园（Eden）：几乎所有的Java对象都在Eden区被new出来（大对象直接进入养老区）。①当Eden区满了且程序又需要创建对象时，触发Minor GC。</li>
<li>Survivor0（From）：③清空Eden区和From区，From区和To区交换。下次GC时，存活的对象进入新的To区。</li>
<li>Survivor1（To）：②复制Eden区和From区的存活对象进To区，年龄加1。</li>
</ul>
<p>IBM研究表明，新生代80%的对象都在此销毁，不会进入老年代。</p>
<p>本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）：</p>
<ul>
<li>对象创建时，按照线程来划分不同的私有空间（Eden区内），OpenJDK衍生的JVM都提供了TLAB的设计。</li>
<li>不是所有的对象实例都能在TLAB中成功分配，但它是JVM内存分配的首选，可通过”-XX:+&#x2F;-UseTLAB“设置是否开启TLAB空间。</li>
<li>默认情况下，TLAB空间内存非常小（Eden的1%），可通过“-XX:TLABWasteTargetPercent”设置其占用Eden区的百分比大小。</li>
<li>一旦对象在TLAB空间分配内存失败，JVM就会尝试通过加锁机制确保数据操作的原子性，从而直接在Eden区分配内存。</li>
</ul>
<h4 id="2）老年代"><a href="#2）老年代" class="headerlink" title="2）老年代"></a>2）老年代</h4><p>老年代（Tenured &#x2F; Old generation，养老区，简写：Old &#x2F; Tenure，OldGen）：④当年龄达到阈值后，进入养老区。养老区空间不足时，触发Major GC，垃圾收集后空间仍然不足导致OOM。</p>
<p>动态对象年龄判断：如果Survivor区相同年龄的所有对象的总大小大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入养老区，不需要等到指定的年龄。</p>
<p>空间分配担保：在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。</p>
<ul>
<li><p>如果大于，那这次Minor GC是安全的。</p>
</li>
<li><p>如果小于，则虚拟机会先查看-XX:HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）。</p>
<ul>
<li><p>如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。</p>
<ul>
<li><p>如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的。</p>
</li>
<li><p>如果小于，则改为进行一次Full GC。</p>
</li>
</ul>
</li>
<li><p>如果不允许，则改为进行一次Full GC。</p>
</li>
</ul>
</li>
</ul>
<p>在JDK 6 Update 24之后，-XX:HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，已经不再使用它。JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC。</p>
<p>Minor GC、Major GC、Full GC区别：</p>
<ul>
<li><p>Minor GC（Young GC &#x2F; YGC）：</p>
<ul>
<li>新生代的垃圾收集。</li>
<li>频率高，速度快，会导致STW（暂停整个应用程序的线程）。</li>
<li>触发时机：Eden区满了且老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，触发Minor GC。</li>
</ul>
</li>
<li><p>Major GC（Old GC）：</p>
<ul>
<li>老年代的垃圾收集。</li>
<li>速度一般比Minor GC慢10倍以上，STW时间更长，Major GC后空间还不足，会导致OOM。</li>
<li>触发时机：老年代空间不足时，通常至少先进行一次Minor GC（不一定），空间仍然不足，触发Major GC。</li>
</ul>
</li>
<li><p>Full GC（FGC）：</p>
<ul>
<li>整个堆和方法区的垃圾收集。</li>
<li>速度最慢，STW时间最长。</li>
<li>触发时机：<ul>
<li>调用System.gc()（或Runtime.getRuntime().gc()）时，系统建议执行Full GC，但不一定执行。</li>
<li>老年代空间不足。</li>
<li>方法区空间不足。</li>
<li>在Minor GC之前，检查到老年代的连续可用空间小于历次晋升到老年代的对象的平均大小，改为Full GC。</li>
<li>把对象从Eden区、From区复制到To区时，To区空间不足且养老区空间也不足。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-2-相关JVM参数"><a href="#3-4-2-相关JVM参数" class="headerlink" title="3.4.2 相关JVM参数"></a>3.4.2 相关JVM参数</h3><p><em>size</em>可选的单位：不写单位（子节）、k、K、m、M、g、G。</p>
<ul>
<li>-Xms<em>size</em>（或-XX:InitialHeapSize&#x3D;<em>size</em>）设置堆的初始大小。</li>
<li>-Xmx<em>size</em>（或-XX:MaxHeapSize&#x3D;<em>size</em>）设置堆的最大值。超出设定的最大值时，导致OutOfMemoryError:heap异常。通常-Xms和-Xmx配置相同的值，避免GC后重新计算分配堆的大小，从而提高性能。</li>
<li>-Xmn<em>size</em>，设置新生代的初始大小（-XX:NewSize&#x3D;<em>size</em>）和最大值（-XX:MaxNewSize&#x3D;<em>size</em>），一般不调整。</li>
<li>-XX:NewRatio&#x3D;2，表示 新生代:老年代 &#x3D; 1:2（默认），新生代占整个堆的1&#x2F;3，一般不调整。</li>
<li>-XX:SurvivorRatio&#x3D;8，表示 Eden:S0:S1 &#x3D; 8:1:1（默认，使用默认值时，具体的比例与收集器有关，JDK 8默认的并行收集器，将其调整为6:1:1）。</li>
<li>-XX:MaxTenuringThreshold&#x3D;15，设置对象进入老年代的年龄（并行收集器默认15，CMS收集器默认6）。</li>
<li>-XX:+PrintGCDetails，开启GC详细信息的打印，默认关闭。</li>
<li>-XX:HandlePromotionFailure，是否允许空间分配担保。</li>
<li>-XX:+PrintFlagsFinal，查看JVM默认参数。（最终值，若默认值被覆盖，显示新值。）</li>
</ul>
<p>默认堆内存大小，<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#default_heap_size">JDK 8官方解析</a>，如下图所示：</p>
<p><img src="/../img/default_heap_size.png"></p>
<p>1）客户端模式的JVM（32位的JDK默认Client模式，java -version查看）：</p>
<ul>
<li>默认最大堆内存：若物理内存小于192MB，默认为物理内存的1&#x2F;2；否则，默认为物理内存的1&#x2F;4，且最大为1024MB&#x2F;4&#x3D;256MB（物理内存大于等于1GB）。</li>
<li>默认最小堆内存：物理内存的1&#x2F;64，但最少8MB；若物理内存大于等于1GB，默认为1024MB&#x2F;64&#x3D;16MB。</li>
</ul>
<p>2）服务器模式的JVM（64位的JDK默认Server模式，且没有客户端模式）：</p>
<ul>
<li>与客户端模式类似，不同的是，最大堆内存为：1GB（32位且物理内存大于等于4G），或32GB（64位且物理内存大于等于128GB）。</li>
</ul>
<p>测试代码1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">System.out.println(<span class="string">&quot;-Xms: &quot;</span> + runtime.totalMemory()*<span class="number">1.0</span>/<span class="number">1024</span>/<span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;-Xmx: &quot;</span> + runtime.maxMemory()*<span class="number">1.0</span>/<span class="number">1024</span>/<span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-4-3-特点"><a href="#3-4-3-特点" class="headerlink" title="3.4.3 特点"></a>3.4.3 特点</h3><ol>
<li>线程共享。</li>
<li>存在GC，存在OOM。</li>
</ol>
<p>堆和栈的区别：</p>
<ol>
<li>堆存在GC，栈不存在GC；堆栈都存在OOM。</li>
<li>堆内存大，执行效率慢；栈内存小，执行效率高。</li>
<li>堆可以是任何数据结构；栈就是栈结构。</li>
<li>堆管对象的存储，栈管方法的运行。</li>
</ol>
<h2 id="3-5-方法区"><a href="#3-5-方法区" class="headerlink" title="3.5 方法区"></a>3.5 方法区</h2><p>​		方法区（Method Area）与堆一样是线程共享的，存储被虚拟机加载的类型信息、常量、静态变量（JDK 7及之后移到堆）、即时编译器编译后的代码等数据。《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，为了与堆区分开来，又叫作“非堆”（Non-Heap）。</p>
<p>方法区在不同JDK版本的实现方式：</p>
<ul>
<li><p>JDK 6：永久代（Permanent Generation，Perm），存储类型信息、常量、静态变量、即时编译器编译后的代码，以及字符串常量池。</p>
</li>
<li><p>JDK 7：永久代（Permanent Generation，Perm），把原本放在永久代的字符串常量池、静态变量等移到堆。</p>
</li>
<li><p>JDK 8：元空间（Meta space，Meta），完全废弃了永久代，改用通过本地内存（Native Memory）来实现的元空间来代替，主要存储类型信息。</p>
</li>
</ul>
<p>方法区的垃圾收集主要有两部分内容：</p>
<ul>
<li>常量池中废弃的常量（字面量和符号引用）。符号引用包括<code>类和接口的全限定名</code>、<code>字段的名称和描述符</code>、<code>方法的名称和描述符</code>。只要常量池中的常量没有被任何地方引用，就可以被回收。</li>
<li>不再使用的类型。需要满足3个条件：1.该类的所有实例都已经被回收；2.加载该类的类加载器已经被回收；3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</li>
</ul>
<p>字符串常量池转移到堆的原因：永久代的回收效率很低，只有Full GC时才会触发，而Full GC频率很低，导致大量的字符串回收不及时。</p>
<p>测试字符串常量池的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhifei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">        System.out.println(s1 == s1.intern());  <span class="comment">// false</span></span><br><span class="line">        System.out.println(s2 == s2.intern());  <span class="comment">// true</span></span><br><span class="line">        System.out.println(s1 == s2.intern());  <span class="comment">// false</span></span><br><span class="line">        System.out.println(s2 == s1.intern());  <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-1-相关JVM参数"><a href="#3-5-1-相关JVM参数" class="headerlink" title="3.5.1 相关JVM参数"></a>3.5.1 相关JVM参数</h3><p><em>size</em>可选的单位：不写单位（子节）、k、K、m、M、g、G。</p>
<ul>
<li>-XX:PermSize&#x3D;<em>size</em>，设置永久代的初始大小，超出设定的大小将触发垃圾收集，默认20.75M。（JDK 8之前）</li>
<li>-XX:MaxPermSize&#x3D;<em>size</em>，设置永久代的最大值，默认64M（32位）、82M（64位）。（JDK 8之前）</li>
<li>-XX:MetaspaceSize&#x3D;<em>size</em>，设置元空间的初始大小，首次超出设定的大小将触发垃圾收集，若回收的空间较大，适当降低触发垃圾收集的阈值，反之，适当提高触发垃圾收集的阈值，Windows默认21M左右，与系统有关。（JDK 8及之后）</li>
<li>-XX:MaxMetaspaceSize&#x3D;<em>size</em>，设置元空间的最大值，默认无限制。（JDK 8及之后）</li>
</ul>
<p>建议：适当地把方法区初始大小设置偏大，避免频繁Full GC。</p>
<h3 id="3-5-2-特点"><a href="#3-5-2-特点" class="headerlink" title="3.5.2 特点"></a>3.5.2 特点</h3><ol>
<li>线程共享。</li>
<li>存在GC（Full GC），存在OOM（加载过多的类）。</li>
</ol>
<h1 id="4-对象内存布局"><a href="#4-对象内存布局" class="headerlink" title="4. 对象内存布局"></a>4. 对象内存布局</h1><h2 id="4-1-对象的实例化"><a href="#4-1-对象的实例化" class="headerlink" title="4.1 对象的实例化"></a>4.1 对象的实例化</h2><h3 id="1）对象创建的方式"><a href="#1）对象创建的方式" class="headerlink" title="1）对象创建的方式"></a>1）对象创建的方式</h3><ol>
<li>new创建。</li>
<li>反射创建。（Class的newInstance()、Constructor的newInstance(参数)）</li>
<li>浅克隆。（实现Cloneable接口的clone()方法）</li>
<li>反序列化。（深克隆）</li>
<li>第三方库Objenesis。（通过asm动态生成Constructor对象）</li>
</ol>
<h3 id="2）对象创建的步骤"><a href="#2）对象创建的步骤" class="headerlink" title="2）对象创建的步骤"></a>2）对象创建的步骤</h3><ol>
<li>类加载。（加载、链接、初始化）</li>
<li>对象内存分配。<ul>
<li>指针碰撞：若内存规整，虚拟机采用指针碰撞法来分配对象内存。意思是已用内存和空闲内存中间用指针作为分界点的指示器，内存分配只需要把指针往空闲内存方向挪动一段与对象大小相等的内存。基于压缩算法的收集器，都采用这种分配方式。</li>
<li>空闲列表：若内存不规整，虚拟机采用空闲列表来分配对象内存。意思是虚拟机通过维护一个空闲内存的列表，在内存分配时，从列表中找到一块足够大的空间进行内存分配，并更新列表上的内容。</li>
</ul>
</li>
<li>对象内存分配的并发问题。<ul>
<li>CAS：对象内存分配时通过CAS来确保原子性。</li>
<li>TLAB：按照不同的线程，在堆中划分一块小的缓冲区用于对象内存分配。</li>
</ul>
</li>
<li>初始化分配的空间。<ul>
<li>把内存空间进行零值初始化（对象头除外）。主要是把实例字段进行零值初始化。</li>
</ul>
</li>
<li>设置对象头。<ul>
<li>将类的元数据、对象的HashCode、对象的GC信息、锁信息等数据存储在对象头。</li>
</ul>
</li>
<li>执行<code>&lt;init&gt;()</code>方法进行初始化。<ul>
<li>初始化实例字段，执行实例化代码块，调用构造方法，并把对象的首地址赋值给引用变量。</li>
</ul>
</li>
</ol>
<p>对应的字节码：</p>
<ul>
<li>new指令：若找不到对应的Class对象，先进行类加载。加载后，在堆中分配内存（Object到当前类路径上所有属性值都要分配内存），然后对其进行零值初始化，分配过程中，引用类型占用4个子节。最后将对象的引用压入操作数栈顶。</li>
<li>dup指令：复制栈顶对象引用，压入栈顶，此时栈顶有两个指向同一对象的引用。如果<code>&lt;init&gt;()</code>方法有参数，还需要将参数进行压栈。靠近顶部的对象引用用来调用方法，靠近底部的对象引用用来赋值或保存到局部变量表。</li>
<li>invokespecial指令：调用对象的实例方法，靠近顶部的对象引用调用<code>&lt;init&gt;()</code>方法。</li>
</ul>
<p>注：<code>&lt;clinit&gt;()</code>是类初始化时执行的方法，<code>&lt;init&gt;()</code>是对象初始化时执行的方法。</p>
<h2 id="4-2-对象的内存布局"><a href="#4-2-对象的内存布局" class="headerlink" title="4.2 对象的内存布局"></a>4.2 对象的内存布局</h2><ul>
<li><p>对象头（Header）：</p>
<ul>
<li>标记字段（Mark Word）：哈希值（HashCode）、偏向的线程ID、GC分代年龄、偏向锁位、锁标志位。</li>
<li>类型指针（Klass Word）：指向元数据区类的元数据（instanceKlass），确定对象的类信息。</li>
<li>数组长度：对象为数组时，记录数组的长度。</li>
</ul>
</li>
<li><p>实例数据（Instance Data）：存储对象的有效信息，包括对象的各种属性（包括父类属性）等。</p>
<p>遵循的规则：</p>
<ul>
<li>相同宽度的字段分配在一起；</li>
<li>父类定义的变量出现在子类之前（父类先于子类加载）；</li>
<li>如果CompactFields参数为true（默认），子类的窄变量可能插入到父类变量的空隙。</li>
</ul>
</li>
<li><p>对其填充（Padding）：非必须，仅仅起到占位符的作用。</p>
</li>
</ul>
<p><img src="/../img/object_structure.png"></p>
<h2 id="4-3-对象的访问定位"><a href="#4-3-对象的访问定位" class="headerlink" title="4.3 对象的访问定位"></a>4.3 对象的访问定位</h2><p>访问定位：栈帧中的reference &#x3D;&gt; 堆中的instanceOopDesc对象 &#x3D;&gt; 方法区中的instanceKlass对象，对象访问方式主流有两种：</p>
<ul>
<li>句柄访问：堆中划分一块内存作为句柄池，reference中存储对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。<ul>
<li>优点：垃圾收集导致对象地址发生改变时，reference不需要修改，只需要修改句柄中对象的指针。</li>
<li>缺点：访问定位时，多了一步定位到句柄的操作。</li>
</ul>
</li>
<li>直接指针访问（HotSpot主要使用）：reference中存储的就是对象地址。访问定位时，不需要多一次定位操作。</li>
</ul>
<h1 id="5-执行引擎"><a href="#5-执行引擎" class="headerlink" title="5. 执行引擎"></a>5. 执行引擎</h1><p>作用：对字节码指令进行解释执行（通过解释器解释执行）和编译执行（通过即时编译器生成机器指令执行）。（字节码指令 &#x3D;&gt; 本地机器指令）</p>
<p>后端编译器：</p>
<ul>
<li>即时编译器（Just In Time，JIT），在程序运行中，把热点代码（热点字节码）转换为可在硬件上直接运行的机器码，并部署至托管环境中（方法区的CodeCache）。</li>
<li>静态提前编译器（Ahead Of Time Compiler，AOT），JDK 9引入，在运行前已经把字节码转换为机器码（.class &#x3D;&gt; .so），避免了”第一次运行慢“的情况，但无法”一次编译，到处运行“，且要求代码在编译期就全部已知。</li>
</ul>
<p>Java是半编译半解释语言：执行引擎中，热点代码通过JIT编译执行，非热点代码通过解释器逐行解释执行。</p>
<p>解释器和即时编译器并存：</p>
<ul>
<li>-Xint：完全采用解释器执行。</li>
<li>-Xcomp：完全采用即时编译器执行。即时编译出现问题，解释器会介入执行。</li>
<li>-Xmixed：采用解析器+即时编译器混合执行。（默认）</li>
</ul>
<p>JIT的热点代码：被多次调用的方法或方法内的循环体，编译的目标都是整个方法，而不是方法内某部分热点代码。由于这种编译方式发生在方法的执行过程中，因此也被叫做栈上替换，简称OSR（On Stack Replacement）编译。</p>
<p>热点探测判断：</p>
<ul>
<li><p>基于采样的热点探测（Sample Based Hot Spot Code Detection）。采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。（J9采用）</p>
<ul>
<li>优点：基于采样的热点探测的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可）。</li>
<li>缺点：很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li>
</ul>
</li>
<li><p>基于计数器的热点探测（Counter Based Hot Spot Code Detection）。采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。（HotSpot采用）</p>
<ul>
<li>优点：统计结果相对来说更加精确严谨。</li>
<li>缺点：实现起来更麻烦，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。</li>
</ul>
</li>
</ul>
<p>HotSpot的热点探测计数器：</p>
<ul>
<li>方法调用计数器：统计方法被调用的次数，默认情况下，Client模式是1500次，Server模式是10000次。超过这个阈值（可通过-XX:CompileThreshold设定），就会触发JIT编译。当一个方法被调用时，虚拟机会先检查该方法是否存在被即时编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将该方法的调用计数器值加一，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。一旦已超过阈值的话，将会向即时编译器提交一个该方法的代码编译请求。</li>
<li>回边计数器</li>
</ul>
<p>热度衰减：在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半，这个过程被称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time），进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样只要系统运行时间足够长，程序中绝大部分方法都会被编译成本地代码。另外还可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p>
<p>HotSpot虚拟机中内置的两个（或三个）即时编译器（由-XX:+RewriteFrequentPairs参数控制，默认server模式。）：</p>
<ul>
<li><p>“客户端编译器”（Client Compiler），简称为C1编译器。可通过-client参数指定，特点：耗时短，优化简单可靠；启动快，占用内存小，执行效率比server慢，默认情况下不进行动态编译，适合桌面应用。优化策略：</p>
<ul>
<li>方法内联：将引用的函数代码编译到引用点处，可以减少栈帧的生成，减少参数传递以及跳转过程。</li>
<li>去虚拟化：对唯一的实现类进行内联。</li>
<li>冗余消除：在运行期间把一些不会执行的代码折叠掉。</li>
</ul>
</li>
<li><p>“服务端编译器”（Server Compiler），简称为C2编译器。可通过-server参数指定，特点：耗时长，优化更为激进，但优化的代码执行效率更高；启动慢，占用内存多，效率高，适合服务端应用。优化策略（基于逃逸分析）：</p>
<ul>
<li>标量替换：用标量值代替聚合对象的属性值。</li>
<li>栈上分配：对未逃逸的对象，内存分配在栈而不在堆。</li>
<li>同步消除：消除同步操作，通常指synchronized。</li>
</ul>
</li>
<li><p>Graal编译器，JDK 10时才出现的、长期目标是代替C2，目前还处于实验状态。</p>
<p>总结：一般来说，JIT编译出来的机器码性能比解释器高；C2编译器启动较C1编译器慢，系统稳定执行后，C2编译器速度远快于C1编译器。</p>
</li>
</ul>
<h1 id="6-垃圾回收"><a href="#6-垃圾回收" class="headerlink" title="6. 垃圾回收"></a>6. 垃圾回收</h1><p>垃圾的定义：运行程序中没有任何指针指向的对象。</p>
<p>为什么需要GC：如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占用的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用，甚至可能内存溢出。</p>
<p>GC的区域：堆（新生代GC频率高，老年代GC频率低）、方法区（GC频率极低）。</p>
<h2 id="6-1-垃圾判定算法"><a href="#6-1-垃圾判定算法" class="headerlink" title="6.1 垃圾判定算法"></a>6.1 垃圾判定算法</h2><h3 id="6-1-1-引用计数法"><a href="#6-1-1-引用计数法" class="headerlink" title="6.1.1 引用计数法"></a>6.1.1 引用计数法</h3><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一。</p>
<ul>
<li>优点：原理简单，判定效率高，回收没有延迟。</li>
<li>缺点：占用额外的内存空间来进行计数；无法处理循环引用的问题。（若非要使用这种算法，可在适当的适合手动解除或使用弱引用。）</li>
</ul>
<h3 id="6-1-2-可达性分析"><a href="#6-1-2-可达性分析" class="headerlink" title="6.1.2 可达性分析"></a>6.1.2 可达性分析</h3><p>一系列的“GC Roots”根对象，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain）。如果某个对象到GC Roots间没有任何引用链相连，说明从GC Roots到这个对象不可达，则此对象是不可能再被使用的。（Java采用的是可达性分析）</p>
<ul>
<li>优点：有效解决引用计数法无法处理循环引用的问题。</li>
</ul>
<p>GC Roots的对象包括（查找所有GC Roots的过程称为枚举根节点）：</p>
<ol>
<li><p>虚拟机栈（栈帧中的局部变量表）中引用的对象，比如：各个线程被调用的方法中使用到的参数、局部变量等。</p>
</li>
<li><p>类静态属性引用的对象，比如：Java类的引用类型静态变量。</p>
</li>
<li><p>方法区中常量引用的对象，比如：字符串常量池（String Table）里的引用。</p>
</li>
<li><p>本地方法栈中JNI（即通常所说的Native方法）引用的对象。</p>
</li>
<li><p>Java虚拟机内部的引用，比如：基本数据类型对应的Class对象，一些常驻的异常对象（NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</p>
</li>
<li><p>所有被同步锁（synchronized关键字）持有的对象。</p>
</li>
<li><p>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p>
</li>
<li><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（Partial GC），如果只针对Java堆中某一块区域发起垃圾收集时（比如：最典型的只针对新生代的垃圾收集），必须考虑到内存区域是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的），更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性。</p>
<p>总结：如果一个指针指向了堆中的对象，而自身又不存放在堆中，则它就是一个GC Roots。</p>
</li>
</ol>
<hr>
<p>并发的可达性分析：用户线程和垃圾收集线程并发执行，目的是缩短用户线程停顿时间。在可达性分析的对象图中：</p>
<ul>
<li>白色：未被垃圾收集器访问过的对象。可达性分析的开始阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的，则代表不可达。</li>
<li>黑色：被垃圾收集器访问过的对象，且这个对象的所有引用都已经扫描过，是安全存活的。如果其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象与白色对象之间一定存在灰色对象。</li>
<li>灰色：被垃圾收集器访问过的对象，但这个对象上至少存在一个引用还没被扫描。</li>
</ul>
<p>并发的可达性分析会出现以下2个问题：</p>
<ul>
<li><p>浮动垃圾：初始标记阶段为存活对象，重新标记为垃圾对象。这种情况可以接受，留到下次GC时清理。</p>
</li>
<li><p>对象消失：初始标记阶段为垃圾对象，重新标记为存活对象。Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：①赋值器插入了一条或多条从黑色对象到白色对象的新引用；②赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。有如下2种解决方案：</p>
<ul>
<li><p>增量更新（Incremental Update）：增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</p>
</li>
<li><p>原始快照（Snapshot At The Beginning， SATB）：原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p>
<p>以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。在 HotSpot虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，比如：CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现。</p>
</li>
</ul>
</li>
</ul>
<h2 id="6-2-垃圾回收算法"><a href="#6-2-垃圾回收算法" class="headerlink" title="6.2 垃圾回收算法"></a>6.2 垃圾回收算法</h2><h3 id="6-2-1-标记-清除算法（Mark-Sweep）"><a href="#6-2-1-标记-清除算法（Mark-Sweep）" class="headerlink" title="6.2.1 标记-清除算法（Mark-Sweep）"></a>6.2.1 标记-清除算法（Mark-Sweep）</h3><p>分为“标记”和“清除”两个阶段，它是最基础的收集算法，后续的收集算法大多都以它为基础，对其缺点进行改进而得到的。标记过程就是垃圾的判定过程，是否可达记录在对象头：</p>
<ul>
<li><p>方法一：标记需要回收的对象，统一回收所有被标记的对象。</p>
</li>
<li><p>方法二：标记存活的对象，统一回收所有未被标记的对象。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>执行效率不稳定，标记和清除两个过程的执行效率都随对象数量增加而降低。</li>
<li>会产生内存碎片，导致在较大对象内存分配时，可能无法找到足够的连续内存而提前触发GC。</li>
</ul>
<p>注意：清除不是真的清空，而是把需要清除的对象地址保存在空闲列表里，下次对象内存分配时，若空间足够，则直接覆盖。</p>
<h3 id="6-2-2-复制算法（Copying）"><a href="#6-2-2-复制算法（Copying）" class="headerlink" title="6.2.2 复制算法（Copying）"></a>6.2.2 复制算法（Copying）</h3><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>优点：</p>
<ul>
<li>不会产生内存碎片。</li>
</ul>
<p>缺点：</p>
<ul>
<li>可用内存缩小为了原来的一半。</li>
<li>如果内存中多数对象都是存活的，会产生大量的内存间复制的开销。适用于对象存活率低的情况，比如：新生代的垃圾回收。</li>
</ul>
<h3 id="6-2-3-标记-整理算法（Mark-Compact）"><a href="#6-2-3-标记-整理算法（Mark-Compact）" class="headerlink" title="6.2.3 标记-整理算法（Mark-Compact）"></a>6.2.3 标记-整理算法（Mark-Compact）</h3><p>它的标记过程与“标记-清除”算法一样，后续让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<p>优点：</p>
<ul>
<li>不会产生内存碎片。</li>
<li>可用内存不用缩小为了原来的一半。</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于老年代这种对象存活率较高的情况，移动存活对象并更新它的引用是极为负重的。STW时间也比其它两种长。</li>
</ul>
<p>三种算法对比：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>标记-清除算法</th>
<th>复制算法</th>
<th>标记-整理算法</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>最快</td>
<td>最慢</td>
</tr>
<tr>
<td>空间</td>
<td>少（会产生内存碎片）</td>
<td>通常需要存活对象的2倍大小（不会产生内存碎片）</td>
<td>少（不会产生内存碎片）</td>
</tr>
<tr>
<td>是否移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="6-2-4-分代收集算法"><a href="#6-2-4-分代收集算法" class="headerlink" title="6.2.4 分代收集算法"></a>6.2.4 分代收集算法</h3><p>不同生命周期的对象采用不同的收集算法，以提高垃圾回收的效率。目前几乎所有的GC都采用分代收集算法（Generational Collecting）来执行垃圾回收，且几乎所有的垃圾收集器都区分新生代和老年代。</p>
<p>新生代：</p>
<ul>
<li>特点：区域较小、对象存活率低、回收频率较高。</li>
<li>具体算法：复制算法。</li>
</ul>
<p>老年代：</p>
<ul>
<li>特点：区域较大、对象存活率高、回收频率较低。</li>
<li>具体算法：标记-清除或标记-清除与标记-整理混用。比如：主打低延迟的CMS收集器，多数时间采取标记-清除算法，当内存碎片程度影响到对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。</li>
</ul>
<h3 id="6-2-5-增量收集算法"><a href="#6-2-5-增量收集算法" class="headerlink" title="6.2.5 增量收集算法"></a>6.2.5 增量收集算法</h3><p>增量收集算法（Incremental Collecting）：为解决垃圾回收时间长导致程序暂停过久的问题。垃圾收集线程每次只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>
<p>优点：低延迟。</p>
<p>缺点：吞吐量下降。</p>
<h3 id="6-2-6-分区收集算法"><a href="#6-2-6-分区收集算法" class="headerlink" title="6.2.6 分区收集算法"></a>6.2.6 分区收集算法</h3><p>将整个堆空间划分成连续的不同小区间，每个小区间独立使用、独立回收。通过控制每次回收的区间数量，来控制GC的停顿时长，比如：G1收集器。</p>
<h2 id="6-3-gc-与finalize"><a href="#6-3-gc-与finalize" class="headerlink" title="6.3 gc()与finalize()"></a>6.3 gc()与finalize()</h2><p>gc()：</p>
<ul>
<li>System.gc()，内部通过Runtime.getRuntime().gc()实现。显式触发Full GC，但不确定是否马上执行。一般情况下，垃圾回收应该是自动进行，无须显式触发。在特殊的性能基准测试时，可能会用到。（测试前调用）</li>
</ul>
<p>finalize()：</p>
<ul>
<li>Object的finalize()方法。被重写的finalize()方法，在对象被首次回收前，由于系统调用，但对象不一定会被回收掉，后续的回收不再调用此方法（关键点：重写、首次）。可用做“关闭外部资源”之类的清理性工作，但如今已被官方明确声明为不推荐使用的语法，使用try-finally或其它方式替换。</li>
<li>详细：如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，比如：把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。如下代码案例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhifei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GCTest</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">GCTest</span>();</span><br><span class="line">        obj = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强制调用重写的finalize()方法。通过Runtime.getRuntime().runFinalization()实现。</span></span><br><span class="line">        <span class="comment">// System.runFinalization();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二次回收</span></span><br><span class="line">        obj = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;GCTest.finalize&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;     <span class="comment">// 模拟没有被回收掉，进行二次回收的情况。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-4-内存溢出与内存泄漏"><a href="#6-4-内存溢出与内存泄漏" class="headerlink" title="6.4 内存溢出与内存泄漏"></a>6.4 内存溢出与内存泄漏</h2><h3 id="6-4-1-内存溢出"><a href="#6-4-1-内存溢出" class="headerlink" title="6.4.1 内存溢出"></a>6.4.1 内存溢出</h3><p>内存空间不足，并且垃圾收集器也无法提供更多的内存。具体OOM（通常在它之前有一次GC）情况：</p>
<ol>
<li>方法区空间不足。（加载过多的类）</li>
<li>堆空间不足。</li>
<li>虚拟机栈空间不足。（没有足够的内存去创建对应的虚拟机栈）</li>
<li>本地方法栈空间不足。（没有足够的内存去创建对应的本地方法栈）</li>
</ol>
<h3 id="6-4-2-内存泄漏"><a href="#6-4-2-内存泄漏" class="headerlink" title="6.4.2 内存泄漏"></a>6.4.2 内存泄漏</h3><p>不再被使用的对象，却仍然存在于内存中（逻辑上不再被使用的可达对象）。具体有如下情况：</p>
<h4 id="1）静态集合类"><a href="#1）静态集合类" class="headerlink" title="1）静态集合类"></a>1）静态集合类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tst1</span> &#123;</span><br><span class="line">    <span class="comment">// 静态集合类属性占用内存会越来越大，生命周期与JVM一样。</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        strList.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）单例模式"><a href="#2）单例模式" class="headerlink" title="2）单例模式"></a>2）单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tst2</span> &#123;</span><br><span class="line">    <span class="comment">// 与静态集合类的情况类似，生命周期与JVM一样。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Tst2</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Tst2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Tst2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Tst2.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Tst2</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3）非静态内部类持有外部类"><a href="#3）非静态内部类持有外部类" class="headerlink" title="3）非静态内部类持有外部类"></a>3）非静态内部类持有外部类</h4><p>非静态内部类对象持有外部类对象的引用，解决办法：改为静态内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tst3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">inner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;Tst3.finalize&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tst3Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Tst3</span> <span class="variable">tst3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tst3</span>();</span><br><span class="line">        Tst3.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> tst3.inner();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 外部类引用置为null，并且显式GC。</span></span><br><span class="line">        tst3 = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非静态内部类对象通过this$0属性引用外部类对象，导致外部类无法被回收，所以它的finalize()方法也不会被调用。</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">$0</span> <span class="operator">=</span> Tst3.Inner.class.getDeclaredField(<span class="string">&quot;this$0&quot;</span>);</span><br><span class="line">        System.out.println(((Tst3) $<span class="number">0.</span>get(inner)).name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4）各种资源连接"><a href="#4）各种资源连接" class="headerlink" title="4）各种资源连接"></a>4）各种资源连接</h4><p>比如：数据库连接、网络连接、IO连接等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tst4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:/abc.txt&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (reader != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 手动关闭连接，避免内存泄漏。</span></span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5）变量不合理的作用域"><a href="#5）变量不合理的作用域" class="headerlink" title="5）变量不合理的作用域"></a>5）变量不合理的作用域</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tst5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        String msg;     // 参数从方法内不合理的调整到方法外，导致msg生命周期与tst5一样。</span></span><br><span class="line">        msg = getMsgFromRemote();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getMsgFromRemote</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6）改变哈希值"><a href="#6）改变哈希值" class="headerlink" title="6）改变哈希值"></a>6）改变哈希值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tst6</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Stu</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">Stu</span> <span class="variable">stu</span> <span class="operator">=</span> (Stu) o;</span><br><span class="line">            <span class="keyword">return</span> Objects.equals(name, stu.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Stu&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;Stu&gt; stuSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        stuSet.add(stu1);</span><br><span class="line">        stuSet.add(stu2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashSet、HashMap的remove方法会先计算key的Hash值（与HashCode相关）。重写了元素类的hashCode和equals，</span></span><br><span class="line"><span class="comment">         * 并且修改了影响hashCode的属性值，导致计算出的Hash值发生了改变，最终导致元素无法移除。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        stu1.setName(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        stuSet.remove(stu1);</span><br><span class="line"></span><br><span class="line">        System.out.println(stuSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7）缓存泄漏"><a href="#7）缓存泄漏" class="headerlink" title="7）缓存泄漏"></a>7）缓存泄漏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tst7</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, String&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设在系统启动时，这些缓存数据从数据库中加载，使用HashMap导致缓存内存泄漏。</span></span><br><span class="line">        <span class="comment">// 可改为WeakHashMap，除自身外，若key没有被引用，那么这个map会丢弃这个键值对。</span></span><br><span class="line">        cache.put(<span class="string">&quot;u1&quot;</span>, <span class="string">&quot;user1&quot;</span>);</span><br><span class="line">        cache.put(<span class="string">&quot;u2&quot;</span>, <span class="string">&quot;user2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8）监听器和回调"><a href="#8）监听器和回调" class="headerlink" title="8）监听器和回调"></a>8）监听器和回调</h4><p>如果客户端在你实现的API中注册回调，没有显式的取消导致内存泄漏。可改为WeakHashMap。</p>
<h2 id="6-5-引用分类"><a href="#6-5-引用分类" class="headerlink" title="6.5 引用分类"></a>6.5 引用分类</h2><p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p>
<ul>
<li>强引用（不回收）：传统定义的“引用”，是指程序中的引用赋值，即类似“Object obj&#x3D;new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，被引用的对象就不会被回收。</li>
<li>软引用（内存不足即回收）：用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li>
<li>弱引用（发现即回收）：也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li>
<li>虚引用（对象回收跟踪）：也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</li>
</ul>
<p>另外，还有一种终结器引用：用来实现对象的finalize() 方法，无需手动编码，内部配合引用队列使用，在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象，然后调用它的finalize()方法，然后收集器对队列中的对象进行第二次小规模的标记，如果对象没有在finalize()中拯救自己，则该对象会被回收。</p>
<p>弱引用测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhifei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakRefTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, String&gt; weakMap = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// key一定要用new String()的方式，不能用字面量，否则会添加到字符串常量池，该字符串还存在引用。</span></span><br><span class="line">        weakMap.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;w1&quot;</span>), <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        weakMap.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;w2&quot;</span>), <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;m1&quot;</span>), <span class="string">&quot;111&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;m2&quot;</span>), <span class="string">&quot;222&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testWeakMap();</span><br><span class="line">        System.out.println(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">        testMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testWeakMap</span><span class="params">()</span> &#123;</span><br><span class="line">        weakMap.entrySet().forEach(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key: &quot;</span> + e.getKey() + <span class="string">&quot;, value: &quot;</span> + e.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        weakMap.entrySet().forEach(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key: &quot;</span> + e.getKey() + <span class="string">&quot;, value: &quot;</span> + e.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMap</span><span class="params">()</span> &#123;</span><br><span class="line">        map.entrySet().forEach(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key: &quot;</span> + e.getKey() + <span class="string">&quot;, value: &quot;</span> + e.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.entrySet().forEach(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key: &quot;</span> + e.getKey() + <span class="string">&quot;, value: &quot;</span> + e.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-6-STW（Stop-The-World）"><a href="#6-6-STW（Stop-The-World）" class="headerlink" title="6.6 STW（Stop-The-World）"></a>6.6 STW（Stop-The-World）</h2><p>指的是在GC过程中，会产生应用程序的停顿。停顿产生时整个应用程序的线程都会被暂停，没有任何响应。</p>
<p>可达性分析中枚举根节点，会导致所有Java执行线程停顿：</p>
<ul>
<li>分析工作必须在一个能确保一致性的快照中进行。一致性指的是整个分析期间，整个系统看起来像被冻结在某个时间点上。</li>
<li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性也无法保证。</li>
</ul>
<h3 id="6-6-1-安全点（Safepoint）"><a href="#6-6-1-安全点（Safepoint）" class="headerlink" title="6.6.1 安全点（Safepoint）"></a>6.6.1 安全点（Safepoint）</h3><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点”。安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的，比如：方法调用、循环跳转、异常跳转等执行时间较长的指令。</p>
<p>垃圾收集时，让所有线程都跑到最近的安全点并停顿下来的方法：</p>
<ul>
<li>抢先式中断 （Preemptive Suspension，目前没有虚拟机使用了）：先中断所有用户线程，如果还有用户线程不在安全点，就恢复线程，直到跑到安全点。</li>
<li>主动式中断（Voluntary Suspension）：设置一个中断标志位，各个线程执行到安全点时主动轮询这个标志，如果中断标志位真，则将自己进行中断挂起。</li>
</ul>
<h3 id="6-6-2-安全区域（Safe-Region）"><a href="#6-6-2-安全区域（Safe-Region）" class="headerlink" title="6.6.2 安全区域（Safe Region）"></a>6.6.2 安全区域（Safe Region）</h3><p>安全点的设计解决了执行中的用户线程的停顿问题，但用户线程处于“不执行”的状态还没解决，比如：用户线程处于Sleep状态或Block状态，无法走到安全点进行中断挂起。</p>
<p>安全区域：在一段代码片段中，引用关系不会发生变化，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。</p>
<p>安全区域的执行与离开：</p>
<ul>
<li>当线程执行到安全区域里面的代码时，先标识自己已经进入安全区域，如果这段时间发起垃圾收集，虚拟机会忽略在安全区域内的线程。</li>
<li>当线程要离开安全区域时，先检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</li>
</ul>
<h2 id="6-7-并行与并发"><a href="#6-7-并行与并发" class="headerlink" title="6.7 并行与并发"></a>6.7 并行与并发</h2><p>并行（Parallel）：</p>
<ul>
<li>CPU角度：同一时间，不同线程运行在不同CPU上。</li>
<li>垃圾收集器角度：多条垃圾收集线程并行工作，此时的用户线程仍处于等待状态。（并行的收集器：ParNew、Parallel Scavenge、Parallel Old，高吞吐量。）</li>
</ul>
<p>串行（Serial）：</p>
<ul>
<li><p>CPU角度：同一CPU，先后执行多个线程。</p>
</li>
<li><p>垃圾收集器角度：单线程执行，如果内存不够，先暂停程序，JVM的垃圾收集器进行垃圾回收后，在启动程序的线程。</p>
</li>
</ul>
<p>并发（Concurrent）：</p>
<ul>
<li><p>CPU角度：同一时间，同一CPU，同时执行多个线程。（交替执行）</p>
</li>
<li><p>垃圾收集器角度：用户线程与垃圾收集线程同时执行，不一定是并行，可能是交替执行。（并发的收集器：CMS、G1，低延迟。）</p>
</li>
</ul>
<h2 id="6-8-七个经典垃圾收集器"><a href="#6-8-七个经典垃圾收集器" class="headerlink" title="6.8 七个经典垃圾收集器"></a>6.8 七个经典垃圾收集器</h2><p>可根据四个维度进行分类：串行与并行、并发式与独占式、压缩式与非压缩式（是否消除内存碎片）、新生代与老年代。</p>
<ul>
<li>串行收集器：Serial、Serial Old（MSC）</li>
<li>并行收集器：ParNew、Parallel Scavenge、Parallel Old</li>
<li>并发收集器：CMS、G1</li>
</ul>
<p><img src="/../img/gc_relation.png"></p>
<p>查看默认GC：</p>
<ul>
<li>-XX:+PrintCommandLineFlags，查看命令行相关参数（包含垃圾收集器）。</li>
<li>命令行指令：jinfo -flag 收集器参数 进程ID，收集器可选值：UseSerialGC、UseParNewGC、UseParallelGC、UseConcMarkSweepGC、UseG1GC。</li>
</ul>
<p>GC评估指标：</p>
<ul>
<li>吞吐量：运行用户代码的时间 &#x2F; （运行用户代码的时间 + 运行垃圾收集的时间）。</li>
<li>垃圾收集开销：吞吐量的补救，垃圾收集器所占时间与总时间的比例。</li>
<li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li>
<li>内存占用：Java堆区所占的内存大小。</li>
<li>快速：一个对象从诞生到被回收所经历的时间。</li>
</ul>
<p>其中，着重关注吞吐量、暂停时间（延迟）、内存占用这3项，通常最多只能同时满足其中2项。随着硬件的发展，极大地提高了内存占用的容忍度，提高了吞吐量。而内存的扩大，反而对延迟带来负面效果。</p>
<p>追求高吞吐：需要降低内存回收的频率，导致垃圾收集器需要更长的暂停时间来回收内存。</p>
<p>追求低延迟：为了降低每次内存回收时的暂停时间，只能频繁执行内存回收，这又导致了新生代内存的缩减和程序吞吐量的下降。</p>
<p>现在JVM调优标准：在最大吞吐量优先的情况下，降低停顿时间。</p>
<h3 id="6-8-1-Serial、Serial-Old"><a href="#6-8-1-Serial、Serial-Old" class="headerlink" title="6.8.1 Serial、Serial Old"></a>6.8.1 Serial、Serial Old</h3><p>​		Serial收集器是最基础、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是HotSpot虚拟机新生代收集器的唯一选择。它是单线程工作的收集器，必须暂停其他所有工作线程（STW机制），直到它收集结束。它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器。</p>
<p>垃圾回收算法：复制算法（Serial，用于新生代）、标记-整理算法（Serial Old，用于老年代）。</p>
<p>优点：简单且在单线程环境下高效（与其他收集器的单线程相比）。</p>
<p>缺点：在多线程环境下，效率低。</p>
<p>应用场景：内存小的用户桌面应用（几十兆甚至一两百兆）。</p>
<p>相关JVM参数：</p>
<ul>
<li>-XX:+&#x2F;-UseSerialGC，使用&#x2F;禁用Serial收集器，默认激活老年代的Serial Old收集器。</li>
</ul>
<h3 id="6-8-2-ParNew"><a href="#6-8-2-ParNew" class="headerlink" title="6.8.2 ParNew"></a>6.8.2 ParNew</h3><p>​		ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为（包括STW机制）都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。</p>
<p>垃圾回收算法：复制算法（用于新生代）。</p>
<p>优点：在多线程环境下，效率高，提升程序吞吐量。除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p>
<p>缺点：在单线程环境下，效率比Serial收集器低。</p>
<p>相关JVM参数：</p>
<ul>
<li><p>-XX:+&#x2F;-UseParNewGC，使用&#x2F;禁用ParNew收集器（不影响老年代）。</p>
</li>
<li><p>-XX:ParallelGCThreads，设置并行收集器的线程数量，当CPU核心数不超过8时，默认等于CPU核心数。</p>
</li>
</ul>
<h3 id="6-8-3-Parallel-Scavenge、Parallel-Old"><a href="#6-8-3-Parallel-Scavenge、Parallel-Old" class="headerlink" title="6.8.3 Parallel Scavenge、Parallel Old"></a>6.8.3 Parallel Scavenge、Parallel Old</h3><p>Parallel Scavenge收集器与ParNew收集器类似（包括STW机制），都是基于并行回收且只在新生代的收集器。与ParNew主要区别：</p>
<ul>
<li>Parallel Scavenge收集器的目标是达到一个可控制的吞吐量，也经常被称作“吞吐量优先收集器”。</li>
<li>Parallel Scavenge收集器具有自适应的调节策略。</li>
</ul>
<p>垃圾回收算法：复制算法（Parallel Scavenge，用于新生代，JDK 1.4提供）、标记-整理算法（Parallel Old，用于老年代，JDK 6才提供）。</p>
<p>优点：吞吐量优先的场景下，与Parallel Old收集器组合使用性能好。（JDK 8默认的组合）</p>
<p>缺点：吞吐量优先，一定程度上增加了停顿时间。</p>
<p>相关JVM参数：</p>
<ul>
<li><p>-XX:+&#x2F;-UseParallelGC，使用&#x2F;禁用Parallel Scavenge收集器，默认激活老年代的Serial Old收集器。</p>
</li>
<li><p>-XX:+&#x2F;-UseParallelOldGC，使用&#x2F;禁用Parallel Old收集器，默认激活新生代的Parallel Scavenge收集器。</p>
</li>
<li><p>-XX:ParallelGCThreads，设置并行收集器的线程数量，当CPU核心数不超过8时，默认等于CPU核心数。</p>
</li>
<li><p>-XX:MaxGCPauseMillis，设置垃圾收集最大停顿时间（毫秒，尽力保证不超过设定值）。垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的：系统把新生代调得小一些，收集300MB新生代肯定比收集500MB快，但这也直接导致垃圾收集发生得更频繁，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。（谨慎使用）</p>
</li>
<li><p>-XX:GCTimeRatio，直接设置吞吐量大小。参数的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。比如：把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5%（即1&#x2F;(1+19)），默认值为99，即允许最大1%（即1&#x2F;(1+99)）的垃圾收集时间。</p>
</li>
<li><p>-XX:+UseAdaptiveSizePolicy，设置Parallel Scavenge收集器具有自适应的调节策略（GC Ergonomics）。当参数被激活后，新生代的大小、Eden与Survivor的比例、晋升老年代对象的年龄等参数会动态调整，以提供最合适的停顿时间或者最大的吞吐量。</p>
<p>如果手工优化存在困难，可以直接使用这种自适应的调节策略。只需设置最大堆、停顿时间（更关注最大停顿时间）或吞吐量大小（更关注吞吐量），具体调节工作交给虚拟机完成。</p>
<p>注意：Parallel这组收集器默认开启这个调节策略，导致Eden:S0:S1 &#x3D; 6:1:1（尽管手动关闭调节策略），可通过-XX:SurvivorRatio&#x3D;8修改为8:1:1。自动调节策略在有些情况下，可能把Survivor调节得很小，导致对象大多进入老年区，从而触发FullGC，在高响应的系统中是不可取的。面对大流量、低延迟系统，不建议启用此参数，可手动设置比例或采用CMS收集器，CMS收集器无论怎么设置，其调节策略固定为false。</p>
</li>
</ul>
<h3 id="6-8-4-CMS"><a href="#6-8-4-CMS" class="headerlink" title="6.8.4 CMS"></a>6.8.4 CMS</h3><p>​		CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。希望系统停顿时间尽可能短，以给用户带来良好的交互体验。在G1收集器出现之前，CMS使用还是非常广泛的，直到今天，仍然有很多系统使用。它的收集过程分为四个步骤：</p>
<ol>
<li>初始标记（CMS initial mark）：仅标记GC Roots能直接关联到的对象，速度很快，需要停顿用户线程（STW）。</li>
<li>并发标记（CMS concurrent mark）：从GC Roots的直接关联对象开始遍历整个对象图，耗时较长但不需要停顿用户线程。</li>
<li>重新标记（CMS remark）：修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间（STW）通常会比初始标记阶段长，但远比并发标记阶段的时间短。（指的是不可达变为可达的对象，可达对象变为不可达的情况会留到下次清理，也叫做浮动垃圾。）</li>
<li>并发清除（CMS concurrent sweep）：清理掉标记阶段判断的已经死亡的对象，因为不需要移动存活对象，所以不需要停顿用户线程。</li>
</ol>
<p>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>垃圾回收算法：标记-清除算法（用于老年代，JDK 5提供）。</p>
<p>优点：并发收集、低延迟。</p>
<p>缺点：</p>
<ul>
<li>产生内存碎片。</li>
<li>对CPU资源非常敏感，虽然在并发阶段不会停顿用户线程，但也占用部分线程而导致程序变慢，吞吐量降低。</li>
<li>会产生浮动垃圾，预留的内存可能无法满足新对象的内存分配，就会出现一次“并发失败”（Concurrent Mode Failure），然后使用Serial Old收集器作为后备预案，效率大大降低。</li>
</ul>
<p>相关JVM参数：</p>
<ul>
<li>-XX:+&#x2F;-UseConcMarkSweepGC，使用&#x2F;禁用CMS收集器，默认激活新生代的ParNew收集器。</li>
<li>-XX:ParallelGCThreads，设置并行收集器的线程数量，当CPU核心数不超过8时，默认等于CPU核心数。</li>
<li>-XX:ConcGCThreads，设置并发收集器的线程数量。</li>
<li>-XX:CMSInitiatingOccupancyFraction，设置触发CMS的老年代空间使用率的阈值（JDK 5默认68%，JDK 6默认92%）。由于垃圾收集阶段用户线程还需要持续运行，所以需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。如果老年代增长不快，可以适当调高这个阈值，降低内存回收频率，获取更好的性能。</li>
<li>-XX:+&#x2F;-UseCMSCompactAtFullCollection，开启&#x2F;关闭Full GC时内存碎片的整理（默认开启，JDK 9废弃），需要移动存活对象，导致停顿时间变长。</li>
<li>-XX:CMSFullGCsBeforeCompaction，设置不整理内存碎片的Full GC次数，经过设定的次数后，下一次Full GC前会整理碎片（默认0，表示每次Full GC都整理碎片，JDK 9废弃）。</li>
</ul>
<h3 id="6-8-5-G1"><a href="#6-8-5-G1" class="headerlink" title="6.8.5 G1"></a>6.8.5 G1</h3><p>​		Garbage First（G1，垃圾优先）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。直至JDK 7 Update 4才移除了“Experimental”的标识，到了JDK 8 Update 40的时候，G1提供并发的类卸载的支持，补全了其计划功能的最后一块拼图，这个版本以后的G1收集器才被Oracle官方称为“全功能的垃圾收集器”（Fully-Featured Garbage Collector）。它主要面向服务端应用，期望未来可以替换掉CMS收集器。JDK 9发布时，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS被声明为不推荐使用（Deprecate）的收集器。</p>
<p>​		G1开创了基于Region的堆内存布局，虽然仍遵循分代收集理论，但其堆内存布局与其他收集器有明显差异：G1不再坚持固定大小、固定数量的分代区域划分，而是把连续的堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演Eden空间、Survivor空间，或老年代空间。收集器对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是旧对象都能获取很好的收集效果。</p>
<p>​		Region中特殊的Humongous区域，用来存储大对象，大小超过了一个Region容量的一半判定为大对象。超过整个Region容量的超级大对象，会被存放在N个连续的Humongous Region之中，G1会把Humongous Region作为老年代的一部分来看待。如下图：</p>
<p><img src="/../img/G1_heap.png"></p>
<p>​		Region是单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，可以避免在堆中进行全区域的垃圾收集。让G1收集器去跟踪各个Region的“价值”大小（即回收获得的空间以及所需的时间），然后在后台维护一个优先级列表，每次根据用户设定的收集停顿时间（-XX:MaxGCPauseMillis，默认200毫秒），优先处理回收价值大的那些Region，这也就是“Garbage First”名字的由来。这种具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p>
<p>它的收集过程大致分为四个步骤（仅并发标记阶段不暂停用户线程）：</p>
<ol>
<li>初始标记（Initial Marking）：仅标记GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li>
<li>并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理原始快照记录下的在并发时有引用变动的对象。</li>
<li>最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的原始快照记录。</li>
<li>筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li>
</ol>
<p>垃圾回收算法：复制算法（用于Region之间，JDK 7提供），但整体上看是标记-整理算法。</p>
<p>优点：相比CMS，G1不会产生内存碎片。在有限的时间内获取尽可能高的收集效率。</p>
<p>缺点：相比CMS，G1内存占用、执行负载更高。通常，堆内存6GB ~ 8GB，CMS与G1性能相当，堆内存更小用CMS，更大则用G1。</p>
<p>相关JVM参数（通常只需要开启G1垃圾收集器、设置堆最大内存、设置最大停顿时间即可）：</p>
<ul>
<li>-XX:+&#x2F;-UseG1GC，使用&#x2F;禁用G1收集器。</li>
<li>-XX:ParallelGCThreads，设置并行收集器的线程数量，当CPU核心数不超过8时，默认等于CPU核心数。</li>
<li>-XX:ConcGCThreads，设置并发收集器的线程数量。</li>
<li>-XX:G1HeapRegionSize，设置每个Region的大小，范围为1MB～32MB，且应为2的N次幂。目标是根据最小的堆大小划分约2048个区域，默认是堆内存的1&#x2F;2000。</li>
<li>-XX:MaxGCPauseMillis，设置垃圾收集最大停顿时间（毫秒，尽力保证不超过设定值）。默认200毫秒。</li>
<li>-XX:InitiatingHeapOccupancyPercent，设置触发并发GC周期的堆占用率阈值。超过即触发GC，默认45。</li>
</ul>
<h2 id="6-9-GC日志参数"><a href="#6-9-GC日志参数" class="headerlink" title="6.9 GC日志参数"></a>6.9 GC日志参数</h2><ul>
<li>-XX:+PrintGC，开启简陋的GC日志，默认输出到标准流，与-verbose:gc类似。</li>
<li>-XX:+PrintGCDetails，开启详细的GC日志，并在进程退出时，输出内存各个区域的分配情况。</li>
<li>-XX:+PrintGCDateStamps，行首记录出现GC的时间。（具体时刻，比如：2019-08-12T18:35:02.783+0800）</li>
<li>-XX:+PrintGCTimeStamps，行首记录出现GC的时间。（启动到出现GC所经过的时间，比如：5.159）</li>
<li>-XX:+PrintHeapAtGC，每次GC前后都打印堆的信息。</li>
<li>-XX:+PrintReferenceGC，记录不同类型的引用回收情况。</li>
<li>-XX:+PrintTenuringDistribution，在每次新生代GC后，打印当前使用的幸存区中对象的年龄分布。</li>
<li>-XX:+PrintGCApplicationStoppedTime，打印GC时线程的停顿时间。</li>
<li>-XX:+PrintGCApplicationConcurrentTime，打印GC前应用未中断的执行时间。</li>
<li>-XX:+PrintSafepointStatistics，打印安全点统计信息。</li>
<li>-XX:PrintSafepointStatisticsCount&#x3D;1，设置安全点统计信息打印的次数。</li>
<li>-Xloggc:&#x2F;logs&#x2F;gc-%t.log，指定保存GC日志的文件，可搭配%t参数使用（JVM启动的时间yyyy-MM-dd_HH-mm-ss）。<a target="_blank" rel="noopener" href="https://gceasy.io/gc-index.jsp">gceasy.io（GC日志在线分析）</a> </li>
<li>-XX:+UseGCLogFileRotation，开启GC日志文件的自动转储。</li>
<li>-XX:NumberOfGCLogFiles&#x3D;5，指定GC日志文件的循环数目（filename.0 ~ filename.N-1），最后一个文件达到指定大小后，从0号文件重新写入。</li>
<li>-XX:GCLogFileSize&#x3D;20M，指定单个GC日志文件的大小。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 必备</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line">-XX:+PrintReferenceGC</span><br><span class="line">-XX:+PrintTenuringDistribution</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime</span><br><span class="line"></span><br><span class="line"># 可选</span><br><span class="line">-XX:+PrintSafepointStatistics</span><br><span class="line">-XX:PrintSafepointStatisticsCount=1</span><br><span class="line"></span><br><span class="line"># GC日志文件</span><br><span class="line">-Xloggc:/logs/gc-%t.log</span><br><span class="line">-XX:+UseGCLogFileRotation</span><br><span class="line">-XX:NumberOfGCLogFiles=5</span><br><span class="line">-XX:GCLogFileSize=20M</span><br></pre></td></tr></table></figure>

<h1 id="7-性能监控"><a href="#7-性能监控" class="headerlink" title="7. 性能监控"></a>7. 性能监控</h1><h2 id="7-1-OOM分析"><a href="#7-1-OOM分析" class="headerlink" title="7.1 OOM分析"></a>7.1 OOM分析</h2><p>相关参数：</p>
<ul>
<li>-XX:+HeapDumpOnOutOfMemoryError，出现OOM时，记录堆转储文件。</li>
<li>-XX:HeapDumpPath&#x3D;&#x2F;logs&#x2F;heapdump.hprof，指定OOM时堆转储文件的位置。通常与-XX:+HeapDumpOnOutOfMemoryError参数一同使用。（若已存在堆转储文件，则不会生成新的堆转储文件）</li>
<li>-XX:OnOutOfMemoryError&#x3D;”脚本”，指定程序或者脚本，出现OOM时，执行这个脚本（例如重启脚本）。</li>
</ul>
<p>分析大致步骤：</p>
<ol>
<li>通过MAT工具分析堆转储文件，判断是内存泄漏还是内存溢出；</li>
<li>若是内存泄漏，通过工具进一步查看泄漏对象到GC Roots的引用链，定位到泄漏的代码；</li>
<li>若是内存溢出，则增大内存。</li>
</ol>
<h3 id="1）堆溢出"><a href="#1）堆溢出" class="headerlink" title="1）堆溢出"></a>1）堆溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhifei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOMTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试OOM并记录堆转储文件，通过jvisualvm观察大对象会直接进入养老区，而不在Eden区，并分析堆转储文件。</span></span><br><span class="line"><span class="comment">     * 配置JVM参数：-Xms6m -Xmx6m -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heapdump.hprof</span></span><br><span class="line"><span class="comment">     * 异常信息：java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] cache = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">2</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            str += UUID.randomUUID().toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因：<ul>
<li>可能存在大对象分配。</li>
<li>可能存在内存泄漏。</li>
</ul>
</li>
<li>解决：<ul>
<li>检查是否存在大对象分配，如：大数组。</li>
<li>通过jmap命令记录堆转储文件，使用MAT工具（内存分析）进行分析，检查是否存在内存泄漏等问题。</li>
<li>若没有明显的内存泄露，增大堆内存。</li>
<li>另外，检查是否存在大量的Finalizable对象，可能由框架内部提供，考虑其存在的必要性。</li>
</ul>
</li>
</ul>
<h3 id="2）GC-overhead-limit-exceeded"><a href="#2）GC-overhead-limit-exceeded" class="headerlink" title="2）GC overhead limit exceeded"></a>2）GC overhead limit exceeded</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhifei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GcOverheadOOMTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试OOM</span></span><br><span class="line"><span class="comment">     * 配置JVM参数：-Xms6m -Xmx6m -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">     * 异常信息：java.lang.OutOfMemoryError: GC overhead limit exceeded</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] cache = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">2</span>];</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因：<ul>
<li>JDK 6新增加的错误类型，一般都是堆太小导致的。超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常。本质是一个预判性的异常，抛出该异常时系统没有真正的内存溢出。</li>
</ul>
</li>
<li>解决：<ul>
<li>检查是否出现大量的死循环或大内存的代码，优化代码。</li>
<li>添加参数-XX:-UseGCOverheadLimit，禁用这个检查，但不能从根本解决问题，最终都会出现java.lang.OutOfMemoryError: Java heap space。</li>
<li>分析堆转储文件，检查是否存在内存泄漏，若不存在，则增大内存。</li>
</ul>
</li>
</ul>
<h3 id="3）方法区溢出"><a href="#3）方法区溢出" class="headerlink" title="3）方法区溢出"></a>3）方法区溢出</h3><p>以元空间为例，加载过多的类导致OOM：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhifei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.xml.internal.ws.org.objectweb.asm.ClassWriter;</span><br><span class="line"><span class="keyword">import</span> com.sun.xml.internal.ws.org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetaspaceOOMTest</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置JVM参数：-XX:MetaspaceSize=20m -XX:MaxMetaspaceSize=20m</span></span><br><span class="line"><span class="comment">     * 异常信息：java.lang.OutOfMemoryError: Metaspace</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MetaspaceOOMTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MetaspaceOOMTest</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                writer.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>,</span><br><span class="line">                        <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="type">byte</span>[] code = writer.toByteArray();</span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);</span><br><span class="line">                times++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;times = &quot;</span> + times);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因：<ul>
<li>运行期间生产大量代理类，导致方法区被撑爆，无法卸载。</li>
<li>应用长时间运行，没有重启。</li>
<li>元空间设置过小。</li>
</ul>
</li>
<li>解决：<ul>
<li>检查元空间设置是否过小。</li>
<li>检查代码中是否存在大量的反射操作。</li>
<li>使用MAT工具分析堆转储文件，检查是否存在大量由反射生成的代理类。</li>
</ul>
</li>
</ul>
<h3 id="4）栈溢出"><a href="#4）栈溢出" class="headerlink" title="4）栈溢出"></a>4）栈溢出</h3><p>创建过多的线程导致OOM，务必在虚拟机下的系统运行，避免线程过多卡死宿主机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package com.zhifei;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOOMTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 务必在虚拟机下的系统运行，避免线程过多卡死宿主机。先javac StackOOMTest.java，再java -Xss1m StackOOMTest，测完kill掉即可。</span></span><br><span class="line"><span class="comment">     * 配置JVM参数：-Xss1m</span></span><br><span class="line"><span class="comment">     * 异常信息：java.lang.OutOfMemoryError: unable to create new native thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testOOM();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testOOM</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.DAYS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因：<ul>
<li>创建线程的数量公式：Number of threads &#x3D; (MaxProcessMemory - JVMMemory - ReservedOsMemory) &#x2F; ThreadStackSize 。<ul>
<li>MaxProcessMemory：进程可寻址的最大空间（32位操作系统为2的32次方，64位为2的64次方）。</li>
<li>JVMMemory：JVM内存。</li>
<li>ReservedOsMemory：保留的操作系统内存。</li>
<li>ThreadStackSize：线程栈的大小。</li>
</ul>
</li>
</ul>
</li>
<li>解决：<ul>
<li>检查是否存在大量不需要的线程。</li>
<li>若需要大量的线程，可通过修改MaxProcessMemory，JVMMemory，ThreadStackSize这三个因素，来增加可创建的线程数。<ul>
<li>使用64位操作系统。</li>
<li>缩小JVM内存分配。</li>
<li>缩小线程栈内存分配。</li>
</ul>
</li>
<li>检查操作系统级别的限制：<ul>
<li>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;pid_max，系统最大pid值。</li>
<li>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;threads-max，系统最大线程数。</li>
<li>maxuserprocess（ulimit -u），系统最大用户进程数。</li>
<li>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;max_map_count，限制一个进程拥有的VMA（虚拟内存区域）数量。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>另外，栈的SOF示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhifei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackSOFTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置JVM参数：-Xss1m</span></span><br><span class="line"><span class="comment">     * 异常信息：java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testSOF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testSOF</span><span class="params">()</span> &#123;</span><br><span class="line">        testSOF();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因：<ul>
<li>方法调用链过长，如：无限递归调用。</li>
</ul>
</li>
</ul>
<h2 id="7-2-命令行工具"><a href="#7-2-命令行工具" class="headerlink" title="7.2 命令行工具"></a>7.2 命令行工具</h2><h3 id="1）jps"><a href="#1）jps" class="headerlink" title="1）jps"></a>1）jps</h3><p>查看Java进程状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">usage: jps [-help]</span><br><span class="line">       jps [-q] [-mlvV] [&lt;hostid&gt;]</span><br><span class="line">Definitions:</span><br><span class="line">    &lt;hostid&gt;:      &lt;hostname&gt;[:&lt;port&gt;]</span><br><span class="line">具体说明：</span><br><span class="line">-q	只显示进程id</span><br><span class="line">-l	输出进程id和进程主类全类名</span><br><span class="line">-m	输出虚拟机进程启动时传递给主类main方法的参数</span><br><span class="line">-v	列出虚拟机进程启动时的jvm参数</span><br><span class="line"></span><br><span class="line">如果某Java进程关闭了默认开启的UsePerfData参数(即使用参数-XX:-UsePerfData) ，那么jps命令(以及jstat)将无法探知该Java进程。</span><br><span class="line">可以通过&lt;hostname&gt;[:&lt;port&gt;]查看远程的主机的java进程，需要搭配jstatd使用，但是不安全，建议本地使用。</span><br></pre></td></tr></table></figure>

<h3 id="2）jstat"><a href="#2）jstat" class="headerlink" title="2）jstat"></a>2）jstat</h3><p>查看JVM统计信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Usage: jstat -help|-options</span><br><span class="line">       jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br><span class="line">示例：jstat -gc -h5 12924 1000 10  输出进程id为12924的统计信息，隔5条输出一个表头，隔1s输出一次，共输出10次。</span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line">  &lt;option&gt;      An option reported by the -options option（可选参数）</span><br><span class="line">  -t			timestamp.（显示程序运行的总时长）</span><br><span class="line">  &lt;vmid&gt;        Virtual Machine Identifier. A vmid takes the following form:</span><br><span class="line">                     &lt;lvmid&gt;[@&lt;hostname&gt;[:&lt;port&gt;]]</span><br><span class="line">                Where &lt;lvmid&gt; is the local vm identifier for the target</span><br><span class="line">                Java virtual machine, typically a process id; &lt;hostname&gt; is</span><br><span class="line">                the name of the host running the target Java virtual machine;</span><br><span class="line">                and &lt;port&gt; is the port number for the rmiregistry on the</span><br><span class="line">                target host. See the jvmstat documentation for a more complete</span><br><span class="line">                description of the Virtual Machine Identifier.（java进程id）   </span><br><span class="line">  &lt;lines&gt;       Number of samples between header lines.(隔多少行输出一次表头信息)</span><br><span class="line">  &lt;interval&gt;    Sampling interval. The following forms are allowed:</span><br><span class="line">                    &lt;n&gt;[&quot;ms&quot;|&quot;s&quot;]</span><br><span class="line">                Where &lt;n&gt; is an integer and the suffix specifies the units as</span><br><span class="line">                milliseconds(&quot;ms&quot;) or seconds(&quot;s&quot;). The default units are &quot;ms&quot;.（隔多长时间输出一次，默认单位ms，可选单位：ms/s）</span><br><span class="line">  &lt;count&gt;       Number of samples to take before terminating.（输出多少次）</span><br><span class="line">  -J&lt;flag&gt;      Pass &lt;flag&gt; directly to the runtime system.</span><br><span class="line"></span><br><span class="line">具体&lt;option&gt;：</span><br><span class="line">1）类装载相关</span><br><span class="line">-class:显示ClassLoader的相关信息: 类的装载、卸载数量、总空间、类装载所消耗的时间等</span><br><span class="line"></span><br><span class="line">2）垃圾回收相关</span><br><span class="line">-gc:显示与GC相关的堆信息。</span><br><span class="line">-gccapacity:显示内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。</span><br><span class="line">-gcutil:显示内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比。</span><br><span class="line">-gccause:与-gcutil功能一样，但是会额外输出导致最后一次或当前正在发生的GC产生的原因。</span><br><span class="line">-gcnew:显示新生代GC状况。</span><br><span class="line">-gcnewcapacity:显示内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间。</span><br><span class="line">-gcold:显示老年代GC状况。</span><br><span class="line">-gcoldcapacity:显示内容与-gcold基本相同，输出主要关注使用到的最大、最小空间。</span><br><span class="line">-gcpermcapacity（或-gcmetacapacity）:显示永久代（或元空间）使用到的最大、最小空间。</span><br><span class="line">结果表头含义：</span><br><span class="line">S0C:S0大小（字节）；S1C:S1大小（字节）；S0U:S0已使用大小（字节）；S1U:S1已使用大小（字节）；</span><br><span class="line">EC:Eden大小（字节）；EU:Eden已使用大小（字节）；OC:老年代大小（字节）OU:老年代已使用大小（字节）；</span><br><span class="line">MC:方法区大小（字节）；MU:方法区已使用大小（字节）；CCSC:压缩类空间大小（字节）；CCSU:压缩类空间已使用大小（字节）；</span><br><span class="line">YGC:Young GC次数；YGCT:Young GC消耗的时间（秒）；FGC:Full GC次数；FGCT:Full GC消耗的时间（秒）；GCT:GC的总时间。</span><br><span class="line"></span><br><span class="line">3）JIT相关</span><br><span class="line">-compiler:显示JIT编 译器编译过的方法、耗时等信息</span><br><span class="line">-printcompilation:输出已经被JIT编译的方法</span><br></pre></td></tr></table></figure>

<h3 id="3）jinfo"><a href="#3）jinfo" class="headerlink" title="3）jinfo"></a>3）jinfo</h3><p>实时查看和修改JVM配置参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jinfo [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jinfo [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    -flag &lt;name&gt;         to print the value of the named VM flag</span><br><span class="line">    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag</span><br><span class="line">    -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value</span><br><span class="line">    -flags               to print VM flags</span><br><span class="line">    -sysprops            to print Java system properties</span><br><span class="line">    &lt;no option&gt;          to print both of the above</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">示例：jinfo -flag ConcGCThreads 1321  查看进程1321的ConcGCThreads参数值。</span><br><span class="line">    </span><br><span class="line">java -XX:+PrintFlagsInitial			查看参数初始值</span><br><span class="line">java -XX:+PrintFlagsFinal			查看参数最终值</span><br><span class="line">java -XX:+PrintCommandLineFlags		查看被修改过的参数</span><br><span class="line">java -XX:+PrintFlagsFinal -version | grep manageable	&#123;manageable&#125;标记的参数是可被实时修改的</span><br></pre></td></tr></table></figure>

<h3 id="4）jmap"><a href="#4）jmap" class="headerlink" title="4）jmap"></a>4）jmap</h3><p>导出内存映像文件和内存使用情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class="line">    -heap                to print java heap summary</span><br><span class="line">    -histo[:live]        to print histogram of java object heap; if the &quot;live&quot;</span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -clstats             to print class loader statistics</span><br><span class="line">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; if not specified,</span><br><span class="line">                                        all objects in the heap are dumped.</span><br><span class="line">                           format=b     binary format</span><br><span class="line">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class="line">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class="line">                         respond. The &quot;live&quot; suboption is not supported</span><br><span class="line">                         in this mode.</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br><span class="line">示例：</span><br><span class="line">jmap -dump:[live,]format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;	手动导出堆内存信息，加live表示只dump出存活的对象。</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=&lt;filename.hprof&gt;	添加这两个参数，在OOM的时会导出内存信息。</span><br></pre></td></tr></table></figure>

<h3 id="5）jhat"><a href="#5）jhat" class="headerlink" title="5）jhat"></a><del>5）jhat</del></h3><p>JDK自带堆分析工具，JDK 9、JDK10中已经删除，官方建议使用VisualVM代替：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Usage:  jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;</span><br><span class="line"></span><br><span class="line">        -J&lt;flag&gt;          Pass &lt;flag&gt; directly to the runtime system. For</span><br><span class="line">                          example, -J-mx512m to use a maximum heap size of 512MB</span><br><span class="line">        -stack false:     Turn off tracking object allocation call stack.</span><br><span class="line">        -refs false:      Turn off tracking of references to objects</span><br><span class="line">        -port &lt;port&gt;:     Set the port for the HTTP server.  Defaults to 7000</span><br><span class="line">        -exclude &lt;file&gt;:  Specify a file that lists data members that should</span><br><span class="line">                          be excluded from the reachableFrom query.</span><br><span class="line">        -baseline &lt;file&gt;: Specify a baseline object dump.  Objects in</span><br><span class="line">                          both heap dumps with the same ID and same class will</span><br><span class="line">                          be marked as not being &quot;new&quot;.</span><br><span class="line">        -debug &lt;int&gt;:     Set debug level.</span><br><span class="line">                            0:  No debug output</span><br><span class="line">                            1:  Debug hprof file parsing</span><br><span class="line">                            2:  Debug hprof file parsing, no server</span><br><span class="line">        -version          Report version number</span><br><span class="line">        -h|-help          Print this help and exit</span><br><span class="line">        &lt;file&gt;            The file to read</span><br><span class="line"></span><br><span class="line">For a dump file that contains multiple heap dumps,</span><br><span class="line">you may specify which dump in the file</span><br><span class="line">by appending &quot;#&lt;number&gt;&quot; to the file name, i.e. &quot;foo.hprof#3&quot;.</span><br><span class="line"></span><br><span class="line">All boolean options default to &quot;true&quot;</span><br></pre></td></tr></table></figure>

<h3 id="6）jstack"><a href="#6）jstack" class="headerlink" title="6）jstack"></a>6）jstack</h3><p>打印JVM中线程快照：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to a hung process)</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to a remote debug server)</span><br><span class="line">Options:</span><br><span class="line">    -F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung)</span><br><span class="line">    -m  to print both java and native frames (mixed mode)</span><br><span class="line">    -l  long listing. Prints additional information about locks</span><br><span class="line">    -h or -help to print this help message</span><br><span class="line">示例：jstack 1321 &gt; stack.log</span><br><span class="line"></span><br><span class="line">信息中重点关注的关键字：</span><br><span class="line">- Deadlock：死锁</span><br><span class="line">- Waiting on condition：等待资源</span><br><span class="line">- Waiting on monitor entry：等待获取监视器</span><br><span class="line">- Blocked：阻塞</span><br><span class="line">- Runnable：执行中</span><br><span class="line">- Suspended：暂停</span><br></pre></td></tr></table></figure>

<h3 id="7）jcmd"><a href="#7）jcmd" class="headerlink" title="7）jcmd"></a>7）jcmd</h3><p>多功能命令，JDK 7新增，实现了除jstat外所有命令的功能，拥有jmap的大部分功能，官方推荐使用jcmd代替jmap：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Usage: jcmd &lt;pid | main class&gt; &lt;command ...|PerfCounter.print|-f file&gt;</span><br><span class="line">   or: jcmd -l</span><br><span class="line">   or: jcmd -h</span><br><span class="line">  command must be a valid jcmd command for the selected jvm.</span><br><span class="line">  Use the command &quot;help&quot; to see which commands are available.</span><br><span class="line">  If the pid is 0, commands will be sent to all Java processes.</span><br><span class="line">  The main class argument will be used to match (either partially</span><br><span class="line">  or fully) the class used to start Java.</span><br><span class="line">  If no options are given, lists Java processes (same as -p).</span><br><span class="line">  PerfCounter.print display the counters exposed by this process</span><br><span class="line">  -f  read and execute commands from the file（从文件读取执行命令）</span><br><span class="line">  -l  list JVM processes on the local machine（列出本地所有JVM进程）</span><br><span class="line">  -h  this help</span><br><span class="line">示例：</span><br><span class="line">jcmd &lt;pid&gt; help	针对指定进程，列出支持的所有命令。</span><br><span class="line">jcmd &lt;pid&gt; &lt;具体命令&gt;	显示指定进程的指令命令数据。</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####################################</span></span></span><br><span class="line">jcmd &lt;pid&gt; GC.heap_dump dump.hprof</span><br><span class="line">等价于</span><br><span class="line">jmap -dump:live,format=b,file=dump.hprof &lt;pid&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####################################</span></span></span><br><span class="line">jcmd &lt;pid&gt; GC.heap_dump -all dump.hprof</span><br><span class="line">等价于</span><br><span class="line">jmap -dump:format=b,file=dump.hprof &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8）jstatd"><a href="#8）jstatd" class="headerlink" title="8）jstatd"></a>8）jstatd</h3><p>远程主机信息收集：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usage: jstatd [-nr] [-p port] [-n rminame]</span><br></pre></td></tr></table></figure>

<h2 id="7-3-GUI工具"><a href="#7-3-GUI工具" class="headerlink" title="7.3 GUI工具"></a>7.3 GUI工具</h2><p>有jConsole (JDK)、Visual VM (JDK，推荐安装VisualGC插件)、eclipse MAT、JProfiler、Arthas、Java Mission Control (JDK)等工具，这里详细介绍Arthas：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">1）基础命令</span><br><span class="line">help 查看命令帮助信息，查看出来的命令的具体用法可以通过，&lt;具体命令&gt; -h查看具体用法</span><br><span class="line">cat 打印文件内容，和linux里的cat命令类似</span><br><span class="line">echo 打印参数，和linux里的echo命令类似</span><br><span class="line">grep 匹配查找，和linux里的grep命令类似</span><br><span class="line">base64 base64编码转换，和linux里的base64命令类似</span><br><span class="line">tee 复制标准输入到标准输出和指定的文件，和linux里的tee命令类似</span><br><span class="line">pwd 返回当前的工作目录，和linux命令类似</span><br><span class="line">cls 清空当前屏幕区域</span><br><span class="line">session 查看当前会话的信息</span><br><span class="line">reset 重置增强类，将被Arthas增强过的类全部还原，Arthas服务端关闭时会重置所有增强过的类</span><br><span class="line">version 输出当前目标Java进程所加载的Arthas版本号</span><br><span class="line">history 打印命令历史</span><br><span class="line">quit 退出当前Arthas客户端，其他Arthas客户端不受影响</span><br><span class="line">stop 关闭Arthas服务端，所有Arthas客户端全部退出</span><br><span class="line">keymap Arthas快捷键列表及自定义快捷键</span><br><span class="line"></span><br><span class="line">2）JVM相关</span><br><span class="line">dashboard 当前系统的实时数据面板</span><br><span class="line">thread 查看当前JVM的线程堆栈信息</span><br><span class="line">jvm 查看当前JVM的信息</span><br><span class="line">sysprop 查看和修改JVM的系统属性</span><br><span class="line">sysenv 查看JVM的环境变量</span><br><span class="line">vmoption 查看和修改JVM里诊断相关的option</span><br><span class="line">perfcounter 查看当前JVM的Perf Counter信息</span><br><span class="line">logger 查看和修改logger</span><br><span class="line">getstatic 查看类的静态属性</span><br><span class="line">ognl 执行ognl表达式</span><br><span class="line">mbean 查看Mbean的信息</span><br><span class="line">heapdump dump java heap, 类似jmap命令的heap dump功能</span><br><span class="line"></span><br><span class="line">3）class/classloader相关</span><br><span class="line">sc 查看JVM已加载的类信息</span><br><span class="line">sm 查看已加载类的方法信息</span><br><span class="line">jad 反编译指定已加载类的源码</span><br><span class="line">mc 内存编译器，内存编译.java文件为.class文件</span><br><span class="line">retransform 加载外部的.class文件，retransform到JVM里</span><br><span class="line">redefine 加载外部的.class文件，redefine到JVM里</span><br><span class="line">dump dump已加载类的byte code到特定目录</span><br><span class="line">classloader 查看classloader的继承树，urls，类加载信息，使用classloader去getResource</span><br><span class="line"></span><br><span class="line">4）monitor/watch/trace相关</span><br><span class="line">monitor 方法执行监控</span><br><span class="line">watch 方法执行数据观测</span><br><span class="line">trace 方法内部调用路径，并输出方法路径上的每个节点上耗时</span><br><span class="line">stack 输出当前方法被调用的调用路径</span><br><span class="line">tt 方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</span><br><span class="line">注意：这些命令通过字节码增强技术来实现，在指定类的方法中插入一些切面来实现数据统计和观测，因此在线上、预发使用时，尽量明确需要观测的类、方法以及条件，诊断结束要执行stop或将增强过的类执行reset命令。</span><br><span class="line"></span><br><span class="line">5）火焰图</span><br><span class="line">profiler 使用async-profiler对应用采样，生成火焰图</span><br><span class="line"></span><br><span class="line">6）鉴权</span><br><span class="line">auth 鉴权</span><br><span class="line"></span><br><span class="line">7）options</span><br><span class="line">options 查看或设置Arthas全局开关</span><br><span class="line"></span><br><span class="line">8）管道命令|</span><br><span class="line">示例：sm java.lang.String * | grep &#x27;index&#x27;</span><br><span class="line">grep 搜索满足条件的结果</span><br><span class="line">plaintext 将命令的结果去除ANSI颜色</span><br><span class="line">wc 按行统计输出结果</span><br><span class="line"></span><br><span class="line">9）后台异步任务，详情请参考https://arthas.gitee.io/async.html</span><br><span class="line">使用 &gt; 将结果重写向到日志文件，使用 &amp; 指定命令是后台运行，session断开不影响任务执行（生命周期默认为1天）</span><br><span class="line">jobs 列出所有job</span><br><span class="line">kill 强制终止任务</span><br><span class="line">fg 将暂停的任务拉到前台执行</span><br><span class="line">bg 将暂停的任务放到后台执行</span><br></pre></td></tr></table></figure>

<h1 id="8-优化案例"><a href="#8-优化案例" class="headerlink" title="8. 优化案例"></a>8. 优化案例</h1><p>通用步骤：</p>
<ul>
<li>监控<ul>
<li>GC频繁</li>
<li>CPU 负载过高</li>
<li>OOM</li>
<li>内存泄漏</li>
<li>死锁</li>
<li>程序响应时间过长</li>
</ul>
</li>
<li>分析<ul>
<li>打印并分析GC日志</li>
<li>灵活运用命令行工具jstack、jmap、jinfo等</li>
<li>转存堆转储文件，使用内存分析工具进行分析</li>
<li>使用Arthas、jconsole、JvisualVM等实时查看JVM状态</li>
</ul>
</li>
<li>优化<ul>
<li>适当增加内存、机器数量</li>
<li>根据业务场景选择垃圾收集器</li>
<li>优化代码，控制内存的使用</li>
<li>合理设置线程池的线程数</li>
<li>使用中间件提高程序效率，比如：缓存、消息队列等</li>
</ul>
</li>
</ul>
<h2 id="8-1-调整堆大小提高吞吐量"><a href="#8-1-调整堆大小提高吞吐量" class="headerlink" title="8.1 调整堆大小提高吞吐量"></a>8.1 调整堆大小提高吞吐量</h2><ol>
<li><p>准备一个SpringBoot项目，并编写测试接口127.0.0.1:8080&#x2F;test，配置JVM参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-Xms40m</span><br><span class="line">-Xmx40m</span><br><span class="line">-XX:SurvivorRatio=8</span><br><span class="line">-XX:MetaspaceSize=64m</span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-Xloggc:./logs/gc-%t.log</span><br></pre></td></tr></table></figure>

<p>注意，如果是普通的Web项目（没有使用SpringBoot），不建议直接修改catalina.sh中的配置，而是在其同级目录下的setenv.sh中添加JVM配置，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export CATALINA_OPTS=&quot;$CATALINA_OPTS -Xms40m&quot;</span><br><span class="line">export CATALINA_OPTS=&quot;$CATALINA_OPTS -Xmx40m&quot;</span><br><span class="line">export CATALINA_OPTS=&quot;$CATALINA_OPTS -XX:SurvivorRatio=8&quot;</span><br><span class="line">export CATALINA_OPTS=&quot;$CATALINA_OPTS -XX:MetaspaceSize=64m&quot;</span><br><span class="line">export CATALINA_OPTS=&quot;$CATALINA_OPTS -XX:+UseParallelGC&quot;</span><br><span class="line">export CATALINA_OPTS=&quot;$CATALINA_OPTS -XX:+PrintGCDetails&quot;</span><br><span class="line">export CATALINA_OPTS=&quot;$CATALINA_OPTS -XX:+PrintGCDateStamps&quot;</span><br><span class="line">export CATALINA_OPTS=&quot;$CATALINA_OPTS -Xloggc:./logs/gc-%t.log&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按照下图设置JMeter配置。</p>
<p><img src="/../img/Snipaste_2024-09-22_12-45-25.png"></p>
</li>
<li><p>对接口进行压力测试，分别查看在堆内存为40m和80m的情况下，聚合报告中接口吞吐量的大小变化。</p>
</li>
</ol>
<h2 id="8-2-JVM优化之JTI优化"><a href="#8-2-JVM优化之JTI优化" class="headerlink" title="8.2 JVM优化之JTI优化"></a>8.2 JVM优化之JTI优化</h2><p>逃逸分析：逃逸分析会对未发生逃逸的对象（只在方法内被调用的对象）进行优化（标量替换、栈上分配、锁消除）。JDK 6u23版本之后，默认开启逃逸分析（-XX:+DoEscapeAnalysis）。在JDK 6中实现，但并不是十分成熟，因为无法保证逃逸分析的性能消耗一定比不使用逃逸分析的消耗低。比如：经过逃逸分析之后，发现所有对象都是逃逸的，那么这个分析的过程就白白浪费了。因此，开发中能使用局部变量的，就不要在方法外定义。</p>
<h3 id="8-2-1-标量替换"><a href="#8-2-1-标量替换" class="headerlink" title="8.2.1 标量替换"></a>8.2.1 标量替换</h3><p>标量（Scalar）是指一个无法再分解成更小的数据的数据，Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。<br>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其包含的成员变量来代替，这个过程就是标量替换。默认允许将聚合量打散分配到栈上（-XX:+EliminateAllocations），这个参数需要开启了逃逸分析才有意义，两者均默认开启。</p>
<p>结论：Java中的逃逸分析，其实优化的点就在于对栈上分配的对象进行标量替换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhifei;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：-Xms100m -Xmx100m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+EliminateAllocations</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScalarReplaceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        stu.id = <span class="number">1</span>;</span><br><span class="line">        stu.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标量替换后</span></span><br><span class="line"><span class="comment">//    private static void alloc() &#123;</span></span><br><span class="line"><span class="comment">//        int id = 1;</span></span><br><span class="line"><span class="comment">//        String name = &quot;Tom&quot;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费时间：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-2-栈上分配"><a href="#8-2-2-栈上分配" class="headerlink" title="8.2.2 栈上分配"></a>8.2.2 栈上分配</h3><p>将堆分配转化为栈分配。经逃逸分析后发现，一个对象并没有逃逸出方法，那么该对象可能会被优化成栈上分配。这样就无需在堆上分配内存，也无需进行垃圾回收，栈空间随着线程的结束被回收。</p>
<h3 id="8-2-3-锁（同步）消除后"><a href="#8-2-3-锁（同步）消除后" class="headerlink" title="8.2.3 锁（同步）消除后"></a>8.2.3 锁（同步）消除后</h3><p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhifei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的加锁对象生命周期只在当前方法中，也即只存在当前线程栈中，不会被其他线程访问到，所以在JIT编译阶段会被优化掉（字节码不变）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            System.out.println(<span class="number">123</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁（同步）消除后：</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    public void test() &#123;</span></span><br><span class="line"><span class="comment">//        Object obj = new Object();</span></span><br><span class="line"><span class="comment">//        System.out.println(123);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3-合理配置堆内存"><a href="#8-3-合理配置堆内存" class="headerlink" title="8.3 合理配置堆内存"></a>8.3 合理配置堆内存</h2><p>估算GC频率：Eden区大小 &#x2F; (每次读取的数据大小 * 每秒读取的次数) &#x3D; 多少秒进行一次GC 。</p>
<table>
<thead>
<tr>
<th>空间</th>
<th>JVM参数</th>
<th>占用系数</th>
</tr>
</thead>
<tbody><tr>
<td>堆</td>
<td>-Xms、-Xmx</td>
<td>FGC后老年代存活对象内存大小的3~4倍。</td>
</tr>
<tr>
<td>方法区（永久代或元空间）</td>
<td>永久代：-XX:PermSize、-XX:MaxPermSize    <br>元空间：-XX:MetaspaceSize、-XX:MaxMetaspaceSize</td>
<td>FGC后方法区使用的内存大小的1.2~1.5倍。</td>
</tr>
<tr>
<td>新生代</td>
<td>-Xmn</td>
<td>FGC后老年代存活对象内存大小的1~1.5倍。</td>
</tr>
<tr>
<td>老年代</td>
<td>通过堆大小减去新生代大小得出</td>
<td>FGC后老年代存活对象内存大小的2~3倍。</td>
</tr>
</tbody></table>
<p>以上只是设置的参考值。除此之外，还要根据GC的回收率，GC停顿耗时，内存里的实际数据来判断，FulIGC是基本上不能有的，如果有就要做内存Dump分析，然后再去做一个合理的内存分配。</p>
<p>判定老年代的存活对象大小：</p>
<ul>
<li>方法1（推荐&#x2F;稳妥）：JVM参数中添加GC日志，GC日志中会记录每次FGC之后各代的内存大小，观察FGC之后老年代的空间大小。可观察一段时间内（比如2天）的FGC之后的内存情况，根据多次FGC之后的老年代的空间大小来预估FGC之后老年代的存活对象大小（取平均值）。</li>
<li>方法2（会影响线上服务&#x2F;慎用）：<ul>
<li>方法1中需要更改JVM参数，并分析日志。同时，在使用CMS收集器时，可能不能触发FGC，导致日志中没有FGC的记录，此时则需要强制触发FGC。在强制触发前，先把服务节点摘除，FGC之后再将服务挂回可用节点，对我提供服务，在不同时间段触发FGC，预估FGC之后老年代的存活对象大小（取平均值）。</li>
<li>强制触发1：<code>jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</code> 将当前的存活对象dump到文件，会触发FGC。</li>
<li>强制触发2：<code>jmap -histo:live &lt;pid&gt;</code> 打印每个class的实例数目、内存占用、类全名信息.live子参数加上后、只统计活的对象数量，会触发FGC。</li>
<li>强制触发3：在性能测试环境，可通过Java监控工具触发FGC，比如：VisualVM、JConsole。</li>
</ul>
</li>
</ul>
<p>以如下接口为例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; LIST = <span class="keyword">new</span> <span class="title class_">ArrayList</span>() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> LIST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置其JVM参数，先设置较大的内存空间，逐步优化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-Xms1024m</span><br><span class="line">-Xmx1024m</span><br><span class="line">-XX:SurvivorRatio=8</span><br><span class="line">-XX:MetaspaceSize=64m</span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-Xloggc:./logs/gc.log</span><br></pre></td></tr></table></figure>

<p>使用“强制触发2”多次触发FGC，通过 <code>jstat -gc &lt;pid&gt; 1000 5</code> 查看GC的统计信息；通过 <code>jmap -heap &lt;pid&gt;</code> 查看堆内存使用情况，这里老年代对象大小为32.23MB、使用的元空间大小为50.47MB，即可得出优化后：堆空间 32.23 x 4 ≈ 128MB；元空间64MB &#x2F; 50.47MB ≈ 1.27（符合条件不做改动），具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-Xms128m</span><br><span class="line">-Xmx128m</span><br><span class="line">-XX:SurvivorRatio=8</span><br><span class="line">-XX:MetaspaceSize=64m</span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-Xloggc:./logs/gc.log</span><br></pre></td></tr></table></figure>

<p>再进行压测，优化前后压测的汇总报告、GC统计信息：</p>
<p><img src="/../img/Snipaste_2024-10-05_17-25-59.png"></p>
<hr>
<p><img src="/../img/Snipaste_2024-10-05_18-46-03.png"></p>
<p>优化结果：YGC次数增加，整体耗时增加，但单次耗时缩短，也未出现FGC，节省了很大一块内存资源。</p>
<h2 id="8-4-CPU高占用的排查"><a href="#8-4-CPU高占用的排查" class="headerlink" title="8.4 CPU高占用的排查"></a>8.4 CPU高占用的排查</h2><p>通用步骤：</p>
<ol>
<li><p>先找到CPU占用率高的Java进程；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep java</span><br></pre></td></tr></table></figure>
</li>
<li><p>罗列该进程下的所有线程，找到可疑线程pid；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -Hp &lt;进程pid&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>jstack 进程pid，并找到对应线程十六进制的pid相关的代码；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-A20表示输出其后20行；<span class="built_in">printf</span> <span class="string">&#x27;%x\n&#x27;</span> &lt;十进制&gt; 表示将10进制转16进制。</span></span><br><span class="line">jstack &lt;进程pid&gt; | grep -A20 `printf &#x27;%x\n&#x27; &lt;线程pid&gt;`</span><br></pre></td></tr></table></figure></li>
</ol>
<p>示例：</p>
<ul>
<li><p>以为死锁代码DeadLockTest.java为例，在Linux下编译并执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>排查过程如下。</p>
<p><img src="/../img/Snipaste_2024-10-06_17-34-39.png"></p>
</li>
<li><p>死锁解决方法</p>
<ul>
<li>调整锁的顺序，保持一致。</li>
<li>采用定时锁，一定时间内获取不到锁，则释放所有自身持有的锁。</li>
</ul>
</li>
</ul>
<h2 id="8-5-G1并发线程数对性能的影响"><a href="#8-5-G1并发线程数对性能的影响" class="headerlink" title="8.5 G1并发线程数对性能的影响"></a>8.5 G1并发线程数对性能的影响</h2><p>使用G1收集器时，-XX:ConcGCThreads主要影响吞吐量，对响应时间影响不大。</p>
<h2 id="8-6-调整垃圾收集器提高吞吐量"><a href="#8-6-调整垃圾收集器提高吞吐量" class="headerlink" title="8.6 调整垃圾收集器提高吞吐量"></a>8.6 调整垃圾收集器提高吞吐量</h2><p>吞吐量（多核）：Serial &lt; Parallel &lt; G1</p>
<h2 id="8-7-日均百万订单系统JVM参数的设置"><a href="#8-7-日均百万订单系统JVM参数的设置" class="headerlink" title="8.7 日均百万订单系统JVM参数的设置"></a>8.7 日均百万订单系统JVM参数的设置</h2><ul>
<li><p>问题1.假设每天300万订单，在3个小时内产生，分析：</p>
<ul>
<li>3000000 &#x2F; 3600 &#x2F; 3 ≈ 278单&#x2F;秒，假设使用3台机器，每台机器每秒大概需要处理100单，假设每单产生1KB数据，则每台每秒产生100KB，订单会涉及其它很多业务（优惠券、库存等），数据放大20倍约2MB。也就是说，每秒大概有2MB的数据在Eden区产生。假设分配给堆4GB内存，默认情况下，Eden区能分配到 4 &#x2F; 3 * 0.8 ≈ 1.06GB（约1085MB），即1085 &#x2F; (2 * 60) ≈ 9分钟进行一次MinorGC，还能接受！此外，若业务再暴增，还可以增加机器或把新生代分配再大一点（降低GC频率，减少进入老年代的对象，从而降低FullGC频率）。</li>
</ul>
</li>
<li><p>问题2.要求响应时间控制在100ms？</p>
<ul>
<li>实际中通过压测去反复测试，分析YGC、FGC的耗时和频率等。</li>
</ul>
</li>
<li><p>问题3.如何处理百万级的并发？</p>
<ul>
<li>下订单、减库存使用中间件（消息队列）进行异步处理。</li>
</ul>
</li>
<li><p>问题4.高PV的资料类网站（磁盘文档读取到内存），升级内存前慢？升级内存后还慢？</p>
<ul>
<li>升级前慢：频繁GC，STW时间较长，响应慢！</li>
<li>升级后慢：内存空间越大，FGC时间越长！</li>
<li>解决：<ul>
<li>垃圾收集器：Parallel、ParNew + CMS、G1</li>
<li>配置参数：-XX:MaxGCPauseMillis、-XX:ConcGCThreads</li>
<li>根据GC日志和Dump文件分析，优化内存空间比例</li>
</ul>
</li>
</ul>
</li>
<li><p>问题5.系统内存飙高排查？</p>
<ul>
<li>jmap -heap、jstat等工具查看内存使用情况；</li>
<li>MAT工具分析Dump文件；</li>
<li>查看GC日志；</li>
</ul>
</li>
</ul>
<h1 id="附页"><a href="#附页" class="headerlink" title="附页"></a>附页</h1><ul>
<li>JVM参数分类<ul>
<li>标准参数：比较稳定，后续版本基本不会变化，以-开头，可以通过java -help查看所有标准选项。</li>
<li>-X参数：非标准化参数，功能比较稳定，但官方说明后续版本可能变更，以-X开头，可以通过java -X查看所有-X选项。</li>
<li>-XX参数：非标准化参数，使用最多的参数类型，属于实验性，不稳定，以-XX开头，用于开发和调试JVM。<ul>
<li><code>-XX:&lt;+|-&gt;&lt;option&gt;</code>，Boolean类型，+表示开启option属性，-表示禁用option属性。</li>
<li><code>-XX:&lt;option&gt;=&lt;number|string&gt;</code>，key-value类型，值可为数字或者字符串。</li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">Java8文档 (oracle.com)</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM/" rel="tag"># JVM</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/09/10/Hexo+NexT%E4%B8%BB%E9%A2%98+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" rel="prev" title="Hexo+NexT主题+GitHub搭建博客">
                  <i class="fa fa-chevron-left"></i> Hexo+NexT主题+GitHub搭建博客
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/04/18/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/" rel="next" title="Docker基础使用">
                  Docker基础使用 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">he-zhifei</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">133k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:05</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span>总访客量</span>
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span>总访问量</span>
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="/js/my_js/canvas-nest.js"></script>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.11.0/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.11.0/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.11.0/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.11.0/next-boot.min.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.11.0/third-party/search/local-search.min.js"></script>




  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.11.0/third-party/pace.min.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"he-zhifei/blog-comments","issue_term":"pathname","theme":"github-light"}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.11.0/third-party/comments/utterances.min.js"></script>

</body>
</html>
